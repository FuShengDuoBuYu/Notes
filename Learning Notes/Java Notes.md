# Java Notes

## Part one

**前言：**

**1.****软件：**

​    软件包括：系统软件（直接和硬件交互的软件win10，Linux）

​              应用软件（常常运行在系统软件中，如QQ运行在Windows系统上）

​              软件开放一般指的是用编程语言开发一个应用软件。

​    软件开发原则之一：开闭原则：对扩展开放，对修改关闭：即软件的扩展中，修改的越少越好

**2.Windows****相关****dos****命令**

​    在dos命令窗口编写dos命令，用win+r可以打开工作台，输入cmd即dos窗口

​    （1）*exit 退出dos窗口

​    （2）*cls 清楚屏幕（clear screen）

​    （3）*ctrl c，v 复制，粘贴

​    （4）*dir 查看当前目录所有子文件 （directory目录）

​    （5）*cd  可以改变目录（change directory）（使用：cd 目录的路径）

​     注：路径分绝对路径和相对路径

​                 绝对路径：表示该路径从某个磁盘的盘符线下作为出发点的路径如：C:\Users\fengchuiyusan>Desktop

​                 相对路径：表示该路径从当前的路径下作为出发点的路径如：直接cd Desktop，是在C:\Users\fengchuiyusan>下找Desktop

​         *cd.. 回到上级目录     *cd\ 回到根目录

​    （6）*字母加：加回车直接切换盘符 （d:回车 是切换至D盘）

​    （7）mkdir abc 创建名字叫abc的文件夹（make directory)

**3.****快捷键：**

​    （1）fn+< = home 回到行首 fn+> = end 回到行尾

​    （2）光标在行尾（首），shift+home（end）是选中一行

​    （3）回到文件尾（首），Ctrl+end（home）

​    （4）查找 Ctrl+f

​    （5）选中单词 鼠标双击 选中一行 鼠标三击

3.Java的文件是要新建.java的文件，因此要保证文件扩展名为.java

4.环境变量中嵌套环境变量时，应该在被引用的环境变量的前后加上%。

 

 

**第一部分：****java****开发准备**

**1.JDK****是什么？**

​    是Java开发工具包，做Java开发必须安装的一个工作包。

**2.Java****分几种？**

​    JavaSE（Java标准版，基础，必学） JavaEE（Java企业版，必学） JavaME（Java微型版，选学）

**3.Java****特性？【开源、免费、纯面向对象、跨平台】**

​    （1）Java语言的底层是C++实现的，不是C语言，Java是完全面向对象的，更符合人的思维

​    （2）Java语言运行时产生的垃圾是自动回收的，不需程序员关系（GC机制）

​    （3）编译以后可以不做任何修改在各种操作系统上运行

原理是让Java程序在一台虚拟的计算机上运行。这个虚拟计算机叫做Java虚拟计算机（JVM），底层同样C++。JVM再和底层操作系统打交道

**4.Java****程序运行包含的阶段？（编译和运行可以在不同系统中进行，叫做跨平台）**

​    （1）编译阶段：（即检查代码是否符合Java语法）

​             xxx.java叫做源文件，内部代码叫源代码，是程序员写的，无法直接运行。

编译检查无误后形成的xxx.class无法直接编辑的（使用JDK中自带的javac.exe命令进行编译）文件叫字节码文件，并非01010110等二进制代码，同样也无法直接运行。

​          javac.exe（Java编译器工具/命令）怎么使用？

​             在DOS命令窗口输入：javac Java源文件的路径

一个Java源文件可以编译生成多个.class文件，字节码文件class是最后要执行的文件，因此生成后可以删除Java源文件，但不建议删除。

​             同一class文件可以拷贝后在不同的操作系统中进行执行，原因就是虚拟机的存在

​    （2）运行阶段

​          xxx.class文件中，xxx叫做“类”，是“类”名。

​          JDK安装后，不光有javac.exe，还有java.exe，负责运行阶段

​          java.exe（Java运行器工具/命令）怎么使用？

​             在DOS命令窗口输入：java 类名（不是路径！）

​                 例：硬盘上有一个 A.class, 应该写做 java A ,而java A.class是错误的

​          运行阶段的过程：

​             （1）打开DOS窗口

​             （2）输入 java 类名（不是路径！）

​             （3）java.exe命令会启动Java虚拟机，（JVM）会启动类加载器ClassLoader

​             （4）类加载器ClassLoader会在硬盘上搜索输入的相应输入的.class文件

​             （5）找到后将该字节码文件装载到JVM中

​             （6）JVM将字节码文件解释成二进制数据，然后操作系统执行二进制文件并且底层硬件平台进行交互。

**5.****第一个****java****程序**

​    1）搞清楚JDK，JRE，JVM的关系，简单而言：JDK>JRE>JVM

​    JDK目录介绍：

​         JDK/bin:该目录下存放了许多命令：

​             javac.exe负责编译

​             java.exe 负责运行

​    2）Windows是怎么搜索硬盘上的某个命令的呢？

​         首先从当前目录下搜索

​         若搜不到，会从环境变量path指定的路径中搜索某个命令

​         若都搜不到，则报错

​    3）配置环境变量

​         path环境变量是Windows操作系统的知识点，是专门给Windows系统指路的

​         故javac想要随意使用，需要将javac的路径目录配置到path中

​    4）在我的电脑的地址目录处输入cmd再回车可以直接在该目录下进入dos命令

**6.****开始第一个程序**

​    1）编译程序：输入javac以后可以将文件直接拖到dos中，也可以输入相对路径，会在源位置生成.class文件

​       注意文件路径都应是英文

​    2）运行程序：java 类名 记得跟的是类名而非路径

​         首先将DOS的目录切换到所要运行程序文件的目录

​         其次输入dir查看是否真的有要运行的程序

​         最后按格式进行运行即可

**7.****打开****DOS****窗口，执行****java** **类名的原理？**

​    （1）java.exe启动JVM

​    （2）JVM启动ClassLoader

​    （3）找到该文件就运行

​    （4）找不到文件就报错

**8.ClassLoader****从哪里搜索字节码文件的呢？**

​    默认下，从当前路径

​    在设置环境变量classpath后，可以在指定路径进行搜索

​    classpath是属于java的环境变量，是给ClassLoader指路的，path是Windows的环境变量

​    换而言之，要么乖乖将路径调整到.class的位置在执行，要么就将classpath的环境变量设置为class文件的路径

​         注：路径中“..”表示上级目录，“."表示当前目录

**9.****关于****java****中的注释？**

​    单行注释：//只注释当前行

​    多行注释:/*

​          多行注释

​                 多行注释

​                 多行注释

​              */

​    javadoc注释：(规范写法，可以用javadoc.exe提取出来，放于帮助文档中便于阅读

​           /**

​           \* javadoc注释 

​                  \* javadoc注释

​                  \* javadoc注释

​                  \* javadoc注释

​                  */

**10.****对****HelloWould****解释：**

  public 表示公开的   class 表示定义一个  static 表示静态的   void 表示空   main 表示方法名是main

​    System.out.println("");向控制台输出消息

​    类体中不能直接写java语句（除了声明变量外）

​    方法体中可编写多个java语句

**11.public class** **和** **class****的区别**

​    （1）一个java源文件中可以定义多个class

​    （2）一个java源文件中不一定有public class，即其不是必须的

​    （3）一个class会定义生成一个对应的xxx.class字节码文件

​    （4）一个java源文件中的定义的公开的类即public 的class只能有一个且其名称必须和java源文件名称一致

​    （5）每一个class都可以编写main方法，都可以设定程序的入口，想执行哪一个class的文件（入口），只需运行哪一个class文件的名字

​         如想执行X.class的主方法：java X

​             注：在命令窗口执行class时，必须要求对应的class有主方法。

 

**第一部分总结及需掌握：**

​    （1）理解java的加载与执行

​    （2）能够自己搭建java的开发环境

​    （3）能够独立编写HelloWould程序，编译并执行

​    （4）掌握环境变量path的原理以及如何配置

​    （5）掌握环境变量classpath原理以及如何配置

​    （6）java中的注释

​    （7）public class和class的区别

​    

 

**第二部分：****java****语言基础**

**1.****关于****java****语言中的标识符**

​    （1）什么是标识符

​         在java源程序中凡是程序员可以自己命名的是标识符

​    （2）标识符可以标识什么呢

​         类名     方法名   变量名   常量名   接口名

​    （3）标识符的命名规则（不按规则编译器会报错）

​         一个合法标识符只能由数字，字符，下划线_，美元符号$中一个或多个组成

​         不能以数字开头    严格区分大小写    关键字不能做标识符     理论上无长度限制

​    （4）标识符的命名规范（只是规范，不属于语法，必做）

​         最好见名知意

​         遵守驼峰命名方式

​             例：SystemService 系统服务，见名知意，且两个单词首字母大写

​         类名、接口名：首字母大写，后面每个单词首字母大写

​         变量名、方法名：首字母小写，后面每个单词首字母大写

​         常量名：全部大写，若有多个单词，则各个单词用下划线隔开

**2.****关于****java****语言中的关键字**

​    （1）什么是关键字

​         在语言中有特殊意义的字符序列，构成了java程序的骨架，这些单词需要记住，不能随意编写，包括大小写

​    （2）关键字在java语言中全部小写

​    （3）常见的关键字有哪些？

​         Public    class     static     void     if   for  while     do   default    byte      short     int   long     float     double    Boolean   char     private    protected  switch    true  false     throw         throws    try    catch

**3.****关于****java****语言中的字面值**

​    （1）什么是字面值(c语言中的常量)

​             10、100  "abc"     'a'   true、false

​             字面值就是数据    字面值，关键字等是java源程序的组成部分

​             数据在计算机编程语言中是有类型的【数据类型】

​                 10       整数型字面值

​                 3.14  浮点型字面值

​                 ture  布尔型字面值

​                 "abc" 字符串型字面值

​                 'a'   字符型字面值

​                     注：java中所有字符串型字面值必须用""括起来

​                         java中所有字符型字面值必须用''括起来

**4.****关于****java****语言中的变量**

​    （1）什么是变量？

​             变量本质是内存中的一块空间，这块空间有数据类型，有名字，有字面值

​             变量包含三部分：数据类型（用来向内存申请多大的空间），名称，字面值（数据）

​             变量是内存中存储数据的最小单元

​    （2）变量要求？

​             变量的存储的数据类型应该和定义的变量类型一致，否则报错

​    （3）变量的定义/声明的格式?

​             数据类型 变量名;

​                 变量名需要是合法标识符，首字母小写，每个单词的首字母大写

​                     例：int i;      int age;   int shoeSize;

​    （4）变量的赋值格式？

​             变量名 = 字面值

​                 字面值的数据类型必须和变量的数据类型一致

​                 等号是赋值运算符，先计算等号右边的结果后再赋值给左边的变量

​    （5）声明和赋值可以一起做，变量赋值以后可以重新赋值

​             int i=10;  

​    （6）访问一个变量有两种方式

​             读取变量的具体数据get/获得

​             修改变量的具体数据set/设置

​    （7）变量在一行上可以声明多个

​             int a,b,c;

​    （8）变量必须先声明再赋值才能访问

​    （9）方法体中的java代码是从上到下逐行依次执行，特点是第x行程序完整结束后第x+1行代码才能执行

​    （10）同一个作用域中，变量名不能重名，但是可以重新赋值

​    （11）变量的作用域？

​             变量的有效范围，出了范围就无法访问变量

​             记住：出了大括号就不认识了

​    （12）变量的分类？

​             根据变量声明的位置进行分类：

​                 局部变量（方法体中声明的变量）

​                 成员变量（方法体外、类体之内声明的变量）

​                     不同作用域中变量的名字可以相同，同一作用域中变量不能重名

​             java遵循就近原则

​                  如果局部变量和成员变量重名并要求输出，则输出局部变量，若局部变量找不到，就输出成员变量

**5.****关于****java****语言的数据类型**

​    （1）数据类型的作用？

​             不同数据类型占用的空间大小不同，数据类型的作用是指导JVM给数据分配多大的空间

​    （2）java中的数据类型？ 

​             基本数据类型【四大类八小种】,八个关键字

​                 第一类：整数型 byte,short,int,long

​                 第二类：浮点型 float,double

​                 第三类：布尔型 boolean

​                 第四类：字符型 char

​                      注：字符串不属于基本数据类型，属于引用数据类型

​             引用数据类型

​                 类       接口     数组

​    （3）八种基本数据类型空间大小（字节）

​             byte          1

​             short         2

​             int           4

​             long          8

​             float          4

​             double        8

​             boolean       1

​             char          2

​    （4）计算机任何时候只识别二进制，只认识1010101010【现代计算机底层采用交流电，只有接通断开两种状态】

​    （5）1个字节等于8个比特位 【1byte=8bit】 一个bit就是一个二进制位

​    （6）byte类型占据一个字节，八个比特位，其数值范围？256个数字，256个不同二进制

​             数字值都有符号位，且位于最左边，0为正数，1为负数

​             byte最大值：01111111=2^7-1=127

​             byte最小值：-128【注意补码】

​    （7）前七种数据类型计算机最好表示，（本质只是二进制）char无法用二进制表示，为了表示文字，使用了ASCII码

​             'a'--(ASCII解码)-->01100001

​             01100001--(ASCII编码)-->'a'

​             当解码与编码采用同一个字典（对照表）时不会乱码

​             反之就会出现乱码

​    （8）ASCII编码【一个字节编码】：'a'--->97 'A'--->65 '0'(文字)--->48

​         最后出现了一种编码方式统一了全球所有文字 UTF-8 UTF-16 UTF-32

​         java语言源代码采用UTF格式，故标识符可以用中文（汉字也是字母）

​         实际开发基本使用UTF-8

​    （9）JDK中自带的native2ascii.exe可以将文字转换为Unicode编码形式

​             直接在cmd中打出native2ascii后再输入中文即可

​             如'中'的是\u4e2d 其中4e2d才是对于的UNI码，\u是将u转义，这个字符代表提醒计算机后面的是Unicode编码

 

 

**第三部分：**

**1.****数据类型的取值范围**

​    byte      -128--127

​    short    -32768--32767

​    char      0--65535

​    boolean       true/false

​         注：short和char所表示种类总数一样，但是char可以标识更大的正整数，因为char无负数

**2.****成员变量未赋值时，系统会自动赋值，而局部变量不会，赋的值是默认值**

​    默认值：

​         byte，short，int，long 0

​         float，double           0.0

​         boolean                    false【C语言中，ture是1，false是0】

​         char                  /u0000 （什么也不是，是空白）

**3.****数据类型详解**

​    （1）字符型：char 可以存储一个中文字符，ab是字符串，不能用单引号做字符用char赋值

​         不可用char时采用“”，类型会不兼容

​         转移字符\ （下坡叫反斜杠，上坡叫正斜杠）想要输出\则需要输入\\，输出'则需要输入\'

​         转移字符出现在特殊字符之前可以将特殊字符变成普通字符

​         \n 换行符

​             其中System.out.println与System.out.print的区别：前者代表输出之后换行，但是后者不换行

​         \t 制表符ASCII码和空格不同

​             16进制：0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a 1b 

​             8进制： 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20

​    （2）整数型：byte，short，int，long

​             java中的整数型字面值默认被当做int型，若想让数据当long来处理，要在数据后面加上大写的L

int i =100;此时声明了i为int，不存在类型转换。 long i = 100；则是将100由int型转变成了long型；数据过大时如2147483648本来就被当做int型，结果溢出了，如long 2147483648就错了，故需要加个L即long 2147483648L，此时没有类型转换

java中的整数型字面值有3中表示方式 八进制【以0开始】，十六进制【以0x开始】，十进制【缺省默认值】常用,计算机输出都是十进制

由long转换成int（大变小）会出现编译报错，不能直接大容量转变成小容量，需要用强制类型转换符将数据进行强制转换，强制转换后可能损失精度，后果可能很严重

​                 由long转int x为long：int y = (int)x;以x=100L为例

​                     原始数据 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100

​                     转换后的数据：00000000 00000000 00000000 01100100 只留右边四个字节

注：当一个整数字面值没有超出byte short char 的取值范围，这个字面值可以直接赋值给byte short char类型的变量，这种机制sun允许，是为了方便程序员

负数的补码是其绝对值的二进制码全部取反后加一，计算机底层都是补码进行存储、运算，整数的补码等于其原码

​    （3）浮点型：float 单精度 【4个字节】

​                  double双精度 【8个字节，精度相对高】

double精度相对较低，不适合财务软件，涉及到钱，sun为程序员在基础SE库中提供了一种引用的数据类型，不属于基本数据类型，为java.math.BigDecimal

sun提供了一套庞大的类库，java程序员是基于这类库进行开发的，需要知道javaSE类库的字节码：C:\Program Files\Java\jdk1.8.0_101\jre\lib\rt.jar。源代码:C:\Program Files\Java\jdk1.8.0_101\src.zip

​                 在java中，所有浮点型字面值默认被当做double型处理

​                 要想变成float来处理，需要在字面值后面添加F\f，(float a = 5.1F) 或者强制类型转换 float a = (float)5.1;

注：float和double在计算机中存储的都是近似值，在现实中有些数据是无限循环的，用有限的存储存无限的数据，因此是近似值。double dd = 10(10.0) / 3； dd=3.0(3.3333333333)；

​    （4）布尔型：boolean

​             在java中，Boolean只有true和false 两个值，没有其他值,不能用0或者1。

​             在底层存储时，boolean占用一个字节，false是0，true是1

​             布尔类型的使用位置：逻辑运算和条件控制语句

**4.****数据类型之间的相互转换：编译就只想编译，程序员不要自己凭空运行**

​    转换规则：编译阶段不进行运算，只检查语法，因此byte h = (byte)(int)5L/3;会编译错误

​         （1）除了布尔类型的，剩下七种类型之间都可以互相转换

​         （2）小容量向大容量转换，叫自动类型转换  long a = b；正确

​             从小到大：byte<short=char<int<long<float<double

​             注：任何浮点类型不论占用多少字节都比整数型容量大

​             char和short可表示的种类数目相同，但是char可以取更大的正整数

​             例如char a = 97 此时就存在由int转为char的类型转换

​         （3）大容量转换成小容量，叫强制类型转换，需要加强制类型转换符才能编译，但是可能会损失精度 

​         （4）当整数型字面值没有超过byte，short，char的取值范围时，可以直接赋值给他们

​         （5）byte，short，char混合运算时，各自先转换成int型再运算

​         （6）多种数据类型混合运算，先转换成容量最大的那种类型进行转换

 

**第二、三部分总结：**

​    1.标识符

​    2.关键字 

​    3.字面值

​    4.变量

​    5.数据类型

​    

**第四部分****:**

​    **1.****运算符**

​         （1）算术运算符

​                 包括+ - * / % ++ --

​                 注：运算符有优先级，不确定就加括号；没必要专门记忆优先级，只要记住加括号就行

​         （2）关系运算符

​                 < > >= <= == != 比较变量保存的值之间的大小

​                 注：关系运算符的运算符结果一定是布尔型 ：ture/false

​         （3）逻辑运算符

​                 & 逻辑与

​                 | 逻辑或

​                 ！逻辑非 ！ture就是false 单目运算符

​                 ^ 逻辑异或 两边的算子只要不一样，就是true

​                 && 短路与

​                 || 短路或

​                     注：逻辑运算符要求两边的算子都是布尔类型，且最终结果也是一个布尔类型

​                         短路与（或）和逻辑与（或）的运算结果相同，只是短路与（或）存在短路现象

​                              用逻辑与（或）时不论前一个条件时真是假，都会去运算第二个算子

​                 用短路与（或）时，若第一个条件为假（真），就不会进行第二个算子,这种叫做短路现象,执行                   较高，短路与更常用，但是特殊情况下，需要用逻辑与

​         （4）字符串连接运算符

​                 \+ 在java中第一个作用是加法求和，第二个就是字符串的连接运算

当加号两边都是数字时，时进行加法运算 当加号两边的数据只要有一个是字符串，就一定会进行字符串连接运算，且结果还是字符串

​                     数字 + 数字 = 数字【求和】 数字 + “字符串” = “字符串”【字符串连接】

​                 一个表达式中可以有多个 + ，在没有小括号的情况下，遵循自左向右的顺序运算

​                 引用类型String 

​                     String是SUN公司在JavaSE中提供的字符串类型，对应String.class字节码文件

​                         类比int，如下： int i = 10; int是基本数据类型，i是变量名，10是int类型的字面值。

​                                      String s = "abc"; String是引用数据类型，s是变量名，"abc"是String类型的字面值

​         （5）三元运算符(三元运算符、条件运算符)

​                 语法规则：布尔表达式 ？ 表达式1 ： 表达式2

​                 执行原理：当布尔为真时，执行表达式1，反之，执行表达式2

​         （6）赋值类运算符

​                 基本的赋值运算符：=

​                 扩展的赋值运算符：+= -= *= /= %=

​                 先执行等号右边的表达式。再将执行结果赋值给左边的变量

其中 byte b = 5; b = b +5; 会报错，因为是int往byte转，编译期只进行语法检查，不运行程序，但是b +=可以正常编译，等同于b = (byte)(b + 5);也即+=自带默认强制转换【int，long等原理一致】

​             扩展类的赋值运算符不改变运算结果的类型，若最初变量为byte，则无论怎么追加或追减，都不会改变变量的类型

​         （7）接收用户键盘输入 java.util.Scanner s = new java.util.Scanner(System.in);//详见java源文件

​                 输出信息到控制台 System.out.println(...)

**第五部分** **控制语句**

​    控制语句可以让程序具有逻辑性和条理性，可以用控制语句来完成业务

​    **1.****选择语句（分支语句）**

​         if语句：任何情况下只有一个分支执行，不可能有两个及以上的分支执行，只要有一个分支执行了，if语句就结束了

​             语法格式：

​                 第一种：if(布尔表达式){

​                              java语句；//大括号{}叫做分支

​                         }

​                 第二种：if(布尔表达式){

​                              java语句；

​                         }

​                         else{

​                              java语句；

​                         }

​                 第三种：if(布尔表达式)//从上往下依次判断{

​                              java语句1；

​                         }

​                         else if(布尔表达式) {

​                              java语句2；

​                         }

​                         else if(布尔表达式){

​                              java语句3；

​                         }

​                         else if(布尔表达式){

​                              java语句4；

​                         }

​                 第四种：if(布尔表达式)//从上往下依次判断{                    

​                              java语句1；

​                         }

​                         else if(布尔表达式){

​                              java语句2；

​                         }

​                         else{

​                              java语句；

​                         }

​                 四种当中，第一种和第三种没有else，可能一个分支都不执行

​                 当分支当中语句只有一条时，大括号可以省略，但是尽量不要省略

​                 控制语句和控制语句之间是可以嵌套的，尽量一个一个的去分析，不要冗杂在一次分析

​                 分析外面的if语句时就把if中的嵌套的if等当做普通java代码就行

​         switch语句

​             语法格式：

​                 switch(值){

​                     case 值1:

​                         java语句;

​                         ...

​                         break;

​                     case 值2:

​                         java语句;

​                         ...

​                         break;

​                      case 值3:

​                         java语句;

​                         ...

​                         break;

​                     default:

​                         java语句;

​                 }

​                 其中break和default不是必须的

​                 值：int型或String型 ，但JDK8之前不支持String，只支持int

​                 byte，short，char也可以使用在switch中，因为他们可以自动转换为int型

​                 

​    **2.****循环语句****:****为了解决代码的复用性**

​         for循环

​             语法结构：

​                 for(初始化表达式;布尔表达式;更新表达式){

​                     循环体（java语句）

​                 }

​                 注：初始化表达式最先执行并整个循环中只执行一次,其中的变量只能在for循环中使用

​                     条件表达式的结果必须是布尔类型，也即true或false

​                     更新表达式是为了控制循环次数，防止出现死循环

​                     所有的合法的“控制语句”都可以嵌套，在分析外面的for时，只需要把里面的for当做普通的java语句即可

​         while循环

​             语法结构：

​                 while(布尔表达式){

​                     循环体;

​                 }

​                 注：布尔的若为真，则执行，直到布尔值为假。

​                     执行0-n次

​         do while循环

​             语法结构：

​                 do{

​                     循环体;

​                 }

​                 while(布尔表达式);

​                 注：不能忘记分号   执行1-n次

​    **3.****转换语句****(break****和****continue****都是一个单词成为一个****java****语句**

​         break

用于switch语句以及循环语句中，用于终止他们，但是不会让整个方法结束，只是用来结束离他最近的循环。用a：for（）{}可以将循环进行命名，可以用break a；来结束指定循环。

​         continue

​             终止本次循环，继续下次循环

​             同样可以指定继续循环，格式和break相同

​         return（先不学）

​         

**第六部分** **方法****(****类似于****C****语言的函数****),****为了提高代码的复用性**

​    **1.****程序开始执行的时候是先执行****main****方法，因为****main****方法是一个入口。**所有方法中的代码都必须按照自上而下的顺序依次执行。main方法不需要由程序员调用（JVM调用），其他方法都需要程序员调用。

​    **2.****方法定义在类体中**，定义的先后顺序没有要求,方法中不能定义方法，方法执行完成后变量（局部变量）的内存会释放，否则会出现变量重名的错误

​    **3.****方法的定义语法**

​         [修饰符列表]  返回值类型 方法名  (形式参数列表)  {方法体}

​         public static    void  main   String[] args  java语句

​         注：[]中里面的内容不是必须的，是可选的，即修饰符列表是选写的，目前都写public static

​    **4.****返回值**

​         （1）返回值就是方法执行结束后的结果，通常是一个数据，因此叫做返回值

(2）返回值可以是任何类型（基本数据类型和引用数据类型），byte，short，int，long，float，double，Boolean，char，String等

​         （3）void不是返回值类型，指的是不返回任何结果，不能空着

​         （4）main方法结束后不需要向JVM返回任何值

（5）返回值是给了调用者，若返回值不是void，则必须在方法的结束时候加上“return 值”的语句执行值得返回，否则报错，只要有return语句执行，则该方法必定结束

​         （6）void的方法不能有“return值；”的语句，但是可以有return；，用来表示方法结束

​    **5.****方法名**

​         （1）方法名要见名知意，单词首字母小写，后面每个单词首字母大写，驼峰命名方式

​    **6.****形式参数**

​         （1）形参列表中每一个参数都是局部变量，方法结束后内存释放

​         （2）形参个数：0-n个，使用逗号隔开每个形参

​         （3）形参的数据类型起决定作用，形参对应的变量名是随意的

​         （4）形参既可以是基本数据类型，也可以是引用数据类型，只要是合法的数据类型

​    **7.****方法体（****java****语句构成，完成特定功能）**

​    **8.****方法调用：**

​         方法定义后必须调用才能执行，定义在那里都可以，没有位置顺序要求

​         语法：类名.方法名（实际参数列表，简称实参，需要和形参完全一一对应）;

​         在方法体里最后可以加return以表式方法结束

​         使用一个变量可以来接收方法的返回值，其中变量的定义需要定义数据类型

​             对于一个没有返回值的方法，不能用一个变量来进行接收

​             一个程序返回值以后，我们可以选择不接收，但是值还是被返回了

​             返回值只能返回一个值，除非是数组

​         调用时可以不加类名.的情况？

a（）方法调用b（）方法时，如果两者在同一个类，可以省略类名.，如果不在同一个类，则不可省略。建议不省略提高可读性

main方法也是一个普通方法，普通的方法也可以去调用别的方法，main方法第一个开始，最后一个结束，main结束后，程序也就结束了

​    **9.return****和****break****的区别**

​         break控制的是终止最近的循环或switch，return是终止当前的方法，两者并不属于一个级别。

​         main方法的返回值是void时，只能写return;（终止main循环）不能写return 10;等

​         return在同一个域中，其下不能再编写其他的代码，否则编译报错

​    **10.****编译中的错误**

​         不能在main方法中去定义其他的方法

​    **11.****方法重载**

也即对于“功能相似”的代码可以让“方法名”相同，从而更有利于以后代码的编写，编译器是根据实参的形式与形参相互对应从而选择某一个方法。

​         因此，在java中，区分方法有两个步骤：1.通过方法名查找 2.当方法相同时，通过相同方法名下的参数类型进行区分

​         什么时候使用方法重载？

在同一个类中，如果“功能1”和“功能2”的功能相似，那么可以考虑将其两个方法名相同，挣扎二氧既可以美观，又可以便于后期的代码编写

​             但是其不可以滥用，一定要在功能的相似的前提下使用，否则会使编码更麻烦，同时命名还要见名知意

​         什么时候可以发生方法重载？

​             1.在同一个类中

​             2.方法名相同

​             3.参数列表不同（参数的个数、类型、顺序不同都算不同）

​             注：不论代码怎么写，最终目标都是让编译器很好的区分两个方法，不在同一个类名下完全不叫方法重载

​         方法重载和返回值类型没有关系，区分两方法的没有返回值类型，靠的是之前提到的两个方法。修饰符列表也是同样的情况

​         println就是一个方法名，它是sun公司提前写好的，它使用了方法重载

​         代码的封装：

​             在一个类中封装了一个代码方法后，只有两个类在同一个文件夹下才可以调用（目前），利用类名.方法名。

​    **12.****方法的递归**

​         什么是递归？

​             方法自己调用自己，就叫做递归

​         当递归程序没有结束条件时，会发生栈内存溢出错误：StackOverflowError。因此递归一定要有结束条件

不建议实际开发中使用递归以免溢出使得JVM死掉，能用for或者while循环代替的尽量用循环(耗费的内存较少，但是少量程序不用递归完成不了

​         如果实际开发中真的遇到 StackOverflowError的解决办法？

​             1.先检查递归的结束条件是否正确

​             2.1若不对，则修改结束条件

​             2.2若正确，这时需要手动调整JVM的栈内存初始化大小，将栈内存的空间调大

​                 扩大的方法:cmd中输入java -X后找到相应的命令为-Xss 综上：java -Xss xxxGB xx.java

​             3.若仍还是报错，再加大

​    **13.****带有****static****和没有****static****的方法的区别**

​             有static的方法用"类名."的方法去调用

​             没有static的方法叫做实例方法，它是对象级别的方法

实例相关的有实例变量，实例方法等，实例方法就是对象方法，实例相关的都需要先new一个对象，通过"引用."的形式去访问

​                     因此实例方法也需要先new对象，再用"引用."的方法访问

​    **14.****不论什么方法（静态方法、实例方法、构造方法）都会在运行时压栈，只是构造方法在结束时会在堆中创建一个对象**

​    **15**.**当源码中一个方法以分号结尾且修饰符列表中有****native****关键字，表示底层调用****C++****写的****dll****程序（动态链接库文件）**

​    **16.java**中**只有类名或者引用后面才可以加****.****，换而言之，****.****前要么是类名，要么是引用**

 

**第六部分（续）**

**1.JVM java****虚拟机的内存数据结构：**

​    JVM中主要有三个区（除了他们三个还有其他的） ：1.栈（stack）内存 2.堆区（堆内存） 3.方法区

**方法区**：类加载器ClassLoader将硬盘上的xxx.class字节码文件装载到JVM时，会将字节码文件放到方法区。即方法区中存储的是代码片段。方法区是最先有数据的。

**栈内存**：在方法被调用时，该方法需要的内存空间在栈中分配，而局部变量是在方法当中的，因此局部变量也在栈中；活动变化最为频繁，一直压栈弹栈。

**堆内存**：凡是同时new运算符创建出的对象，都存储在堆内存中。new运算符的作用就是在堆内存中开辟一片空间，堆内存中存储对象以及对象的实例变量

java中的垃圾回收器GC主要针对回收的是堆内存中的垃圾数据，当没有任何的引用指向对象时，该对象就会被清理回收

**2.****栈数据结构（****stack****）**

​    数据结构指的是存储数据的容器，而该容器存在不同的结构。数据结构实际上和java是没有关系的，是一个独立的学科。

​    常见的数据结构：数组、链表、图、树、栈、队列等

​         队列：先进先出 栈：先进后出

​    常见的算法结构：排序算法、查找算法等

​    数据先进栈（入栈、压栈、push），数据然后再出栈（弹栈、pop），最先进去的元素叫栈底元素，最后进去的是栈顶元素。栈帧永远指向栈顶元素，处于栈顶的元素具备活跃权。

**3.****方法执行中内存的变化**

​    局部变量只在方法体中有效，一旦方法结束，局部变量的内存就释放了

​    栈内存：方法调用的时候，该方法需要的内存空间在栈中分配

​    方法如果不调用时是不会在栈中分配空间的，只有在调用时才会分配空间，并且在调用的时候就是压栈，执行结束后该方法所需要的空间就会释放，此时就是弹栈。

​    因此：方法调用叫做压栈（分配空间），方法结束叫做弹栈（释放空间），因此栈中存储方法运行时所需要的内存以及存储方法时的局部变量

**4**.理解当main方法调用m1方法，m1方法调用m2方法，m2方法调用m3方法的压栈和弹栈的过程，其中栈帧是不断变化的，也正因为函数调用的存在，使得main在最底下，m3在最顶上，使得弹栈的顺序是从最后调用的方法到main方法

**5.****不同方法中的局部变量是没有任何联系的，是几个完全不同的存储空间等变量**    

**6.****太计较变量的数量的后果（其实计算机不差这点内存）：**

​    1.代码的可读性差

​    2.可能会形象到编程的效率（运行效率不会有变化）

​    3.在编码中，有可能必须要定义变量，因为会有后面运算用到它。

 

**第七部分** **面向对象**

**1.****面向对象和面向过程的区别**

​    从语言而言：

​         对于C语言而言，是面向过程。C++是半面向对象，半面向过程。对于java而言，是完全面向对象的

​    面向过程的开发方式

面向过程的开发方式的特点是注重步骤，也即第一步、第二步等，注重实现功能的因果关系，因为有A所以B，因为B所以C等

​         面向过程中没有对象的概念，只是实现功能的步骤和因果关系

​         缺点：其最重要的是各步骤之间的因果关系，A步骤和B步骤因因果关系构成模块，不同模块之间靠因果关系连接，假设有一个代码因果出错，则整个系统都出错（代码的耦合度太高，扩展力太差）

​         优点：对于小型项目，效率较高，不需要进行对象的提取，模型的建立，采用面向过程可以直接开始干活（快速开发）

​    面向对象的开发方式

​         更符合人类的思维方式，面向对象更容易让我们接受。

​         采用面向对象开发，耦合度低，扩展力强。

**2.OOA****：面向对象分析**       **OOD:****面向对象设计**     **OOP****：面向对象编程**

​    实现一个软件：分析-->设计-->编程

**3.****面向对象的三大特征（****python****、****java****、****C#****）**

​    1.封装    2.继承    3.多态    

**4.****类和对象（实例）的概念**

​    术语：   类   对象     实例     实例化   抽象

​    什么是类： 

​         类实际上在现实世界中并不存在，是我们大脑进行思考、总结、抽象的一个结果

​         例如：“女朋友”是类，而XXX是对象。

​         由对象抽取共同特征形成类的过程叫抽象。

​    什么是对象：

​         对象是实际存在的个体。

​         类就是对象特征的总结，描述的是对象的共同特征信息

​    因此，要想得到对象，首先要先定义类，对象是通过类这个模板创造出来的

​         类就是一个模板，对象就是通过类创建出的个体，这个过程叫实例化（创建）。

​    类----实例化--->对象（实例）

​    对象---抽象--->类

​    共同特征都包括什么呢？

​    类 = 属性 + 方法

​         属性来源于状态，方法来源于动作

**5.java****软件工程师在开发中的作用？**

​    我们需要剧具备观察+抽象能力，将现实世界中的对象1和对象2有什么共同特征，然后再java中用类来描述这些共同特征

​    然后通过类来实例化对象，从而让各个对象互相协作形成系统，模拟现实世界

**6.****类的定义**

​    定义类的语法格式：（修饰符列表可以省略）

​         [修饰符列表] class 类名{

​             //类体 = 属性 + 方法

​             属性在代码上以变量的形式存在（描述状态）

​             方法在代码上以方法的形式存在（描述动作/行为）

​         }

​    为什么属性以变量的形式存在？

​         因为属性对应的是数据，数据必须存在变量中，属性其实就是变量

​         方法体内声明的变量是局部变量，方法体外声明的变量是成员变量，这里的成员变量就是属性

​         变量本应先声明再赋值才能运用，但是成员变量没有赋值时，系统会默认赋值，赋的值都是默认值，赋值是在构造方法的执行过程中才完成初始化完成赋值的。

​             默认值：byte 0；short 0； int 0； long 0L； float 0.0F； double 0.0； Boolean false； char '\u0000'

​                     引用数据类型 null； null是一个java关键字，全部小写，表示空，是引用数据类型的默认值

**7.****对象的创建和使用**

​    创建对象的语法

​    new 类名()； new 类名() 就是一个对象，由该类创建出的对象

​    类是模板，通过一个类，可以创建N个对象，其中new是一个运算符，用来创建对象

​         例子：已知有一个class Student

​              则可以通过new Student();来创建一个对象，而要访问这个对象就要把它给到变量中

​              所以有 类名 变量名 = new 类名(); 即：Student s1 = new Student();

​              在这里，s1是变量名，Student是变量s1的数据类型，java中所有的类都属于引用数据类型

​              而其实s1是被赋了对象Student在对内存中的地址，类似这种保存了对象内存地址的变量，这个局部变量叫做引用；

**8.****编译的过程**

​    使用javac *.java 可以直接编译所有java文件，从而不再有出现创建对象应该先编译哪一个的困惑了

**9.****对象的创建和使用（续）**

​    什么是实例变量？

​         实例变量就是对象级别的变量

​         即，每个对象都有的变量但是每个对象的这个变量的值都不同

​    实例变量访问时，是不是必须要先创建对象？

​         不可以。不可以通过类名来直接访问实例变量

​    对象与引用的区别

​         对象是堆里new出来的，在堆内存中存储

​         引用：但凡是变量，并且该变量保存了内存的地址指向了堆内存当中的对象。是存储对象内存地址的换一个变量

​             引用既可以是成员变量，也可以是局部变量

​    怎么访问实例变量？

​         语法：引用.实例变量名

​         可以正常用 = 赋值，用println打印等等

**10.****画内存图的注意事项**

​         为什么画内存图？

​             程序不运行，也可以知道结果

​             有了内存图，有利于调试程序

​         应该有画图形的先后顺序，代码是有执行顺序的，程序执行到哪里就画哪里

​         内存图上不应体现代码，内存上应该体现出“数据”

​         只有地址指向对象，没有对象指向地址

​         int x = 100; int y = x; 将100复制一份给y，也即将其中保存的东西传过去，不分什么值传递什么的

即参数传递时，和类型无关，不管是基本数据类型还是引用数据类型统一都是将盒子中的那个“值”赋值一份，保存下去（内存地址也是值）

​         画内存图的方法

​             第一步：类加载

​             第二步：调用当前类的main方法

**11.****空指针异常（****NullPointerException****）**

​    什么时候回空指针异常呢？

​         “空引用”访问实例【对象】相关的数据时，都会出现空指针异常，因此静态变量不会出现空指针异常

**12.****构造方法**

​    什么是构造方法？有什么用？

是一个比较特殊的方法，通过构造方法可以完成对象的创建以及实例变量的初始化即为实例变量开辟内存空间。（实例变量未手动赋值时系统会赋默认值）

当一个类没有提供任何构造方法时，系统会默认提供一个无参数的构造方法（重点，需要记忆）这个构造方法被叫做缺省构造器。当一个类中手动提供了构造方法，那么系统将不再提供无参数构造方法。建议提前写出无参构造方法。

​         无参构造方法中虽然什么都没写，但实际上是在方法中将实例变量默认值初始化

​    

​    怎么调用构造方法？语法结构？

​         使用new运算符来调用构造方法；new后面就是个构造方法；

​    有参数和无参数的构造方法都可以调用，都支持方法重载，一个类中可以多个构造方法，且所有的构造方法名字都是一样的，但是参数列表是不同的

​             调用构造方法语法格式：

​                 new 构造方法名(实参);

​         构造方法语法结构：（不可以写返回值类型）

​             [修饰符列表] 构造方法名(形式参数列表){

​                 构造方法体;

​             }

​                 注：修饰符列表现在统一写public，不写public static

​                     构造方法名必须和类名一致

​                     构造方法不需要指定返回值类型，也不能写void，若写了，就成了普通方法

​                     通常在构造方法体中给属性赋值，完成属性的初始化

​         普通方法语法结构：

​             [修饰符列表] 返回值类型 方法名(形参列表){

​                 方法体;

​             }

 

**第八部分：封装**

**1.****要想继承，先得封装；要想多态，先得继承。**

**2.****什么是封装？有什么用？**

​    作用：保护内部结构的安全    屏蔽复杂，暴露简单

​         一个类体中的数据，封装后，对于代码的调用人员就不需考虑其复杂实现，只需一个简单的入口

​         通过封装杜绝外部人员的数据更改，提高数据的安全性   

​             访问一个对象的属性有两个操作：读数据(get)和写数据(set)；未封装时可以随意对类里的属性进行访问，导致不安全

**3.****怎么封装？**

​    第一步：属性私有化(使用private关键字进行修饰)

​    第二步：对外提供简单的操作入口，即对外提供公开的set和get的方法来作为操作入口，且都不带有static

​    语法结构：

​         在关键字前加一个private。private表示私有的，被这个关键词修饰以后，该数据只能在本类中访问，出了这个类这个属性就不能访问了

​             例：private int i；此时i彻底不能在外部访问了，但是有些太安全了，i不能访问，此时的程序就意义不大了

**4.   get****和****set****方法都应该是实例方法，不加****static****，因为读和写都是某一个对象的数据**

​    get和set的书写规范中：

​         get方法：public 返回值类型 get+属性名首字母大写（无参）{

​             return xxx；

​         }

​         set方法：public void set+属性名首字母大写（有一个参数）{

​             xxx = 参数；

​         }

​         可以在set中加入判断条件，通过if语句来设置关卡

**5.****封装代码的两步走**

​    1.属性私有化（加private）

​    2.一个属性提供两个方法（set和get），外部程序只能通过get和set方法来对数据进行读和写，可以在set中设置关卡保证数据的安全性

​         注：set和get都不加static，都必须先new对象。其定义时要符合规范

​    3.即使某个变量的setget方法用不到也要将其写上去，因为这是封装规范所必须的

**6.static****关键字**

​    1.static概述

​         1.所有static关键字修饰的都是类相关的，类级别的

​         2.所有static修饰的，都是采用“类名.”的方式访问

​         3.static修饰的变量和方法：静态变量和静态方法

​         4.成员变量可以分为：实例变量和静态变量两个部分

​             int i；实例变量 static int i；静态变量

​             public static void m1（）{}静态方法

​             public void m2（）{}实例方法

​             静态的都用“类名.”去访问，不可能会空指针异常

​             实例的都用“引用.”去访问，可能会空指针异常

​    2.什么时候声明实例还是静态变量？

​         堆里存实例变量，栈里存局部变量

​         加有static的变量是静态变量，在类加载时初始化，不需要new对象，静态变量的空间就开出来了，存储在方法区，一般直接在代码中给出值

​             因此：各种（三大变量）变量的存储地址：

​                     局部变量：栈，（包括new出对象的局部变量）

​                     实例变量：堆

​                     静态变量：方法区

​                     实例变量+静态变量=成员变量

​         静态变量应该用类名.的方式访问,但是引用.的方式同样也可以访问，但不建议用引用. 同时空指针访问静态变量不会出现空指针异常

​         如果这个类型的所有对象的某个属性值都是一样的，不建议定义为实例变量，浪费内存

​         建议定义为类级别特征，定义为静态变量，在方法区中只保留一份，节省内存开销    

​    3.总结下来：

​         静态的东西都用类名.来访问，实例的东西都先new对象，用引用.来访问

​         当方法体中访问了实例变量，该方法必须是实例方法

​         在大部分开发中，一般是工具类时，工具类中的方法一般都是静态的（不需要new对象，直接用类名调用，十分方便）

​    4.使用static可以定义静态代码块

​         什么是静态代码块？

​             语法：static{java语句；}

​             在类加载时执行且只执行一次，一个类里可以有多个静态代码块，一旦是代码，一定在方法区存储

​             静态代码块在main方法执行前执行

​         静态代码块的作用？

​             不常用，不是每个类都要写

​             静态代码块是为了给程序员一个特殊的时机，叫做类加载时机

​                 例如日志的加载就是放在静态代码块中

​         static的静态代码块可以访问静态变量,而实例变量不行（一定是从上到下，才可以访问静态变量）

**7.****目前有顺序要求的代码：**

​    1.方法体中的代码从上而下

​    2.静态代码块之间的从上而下

​    3.静态代码和静态变量是有先后顺序的

**8.****实例代码块**

​    语法：直接大括号加语句{

​         语句；

​    }

​    实力语句块在构造方法时执行

**9.this** **关键字（以后写代码都要封装，使用****get****和****set****）**

​    this是关键字，全小写

​    this是一个变量，是一个引用，保存当前对象的内存地址指向自身，因此

​    this代表的就是当前对象，this存储在堆内存中对象的内部，即自己指向自己

​    this只能使用在实例方法中，this不可出现在静态方法中，谁调用这个实例方法，this就是谁，因此this代表的是当前对象

​    this.大部分情况下是可以省略的，在实例方法中实例变量前默认有this.保证有对象的引用.

​    我们在构造set方法时，为了提高可读性，应该合理利用this.

​         例：class a{

​             private int id;

​             public void setId(int i){

​                 id = i;//此时的i变量的可读性就很差，因此应该用下面的变量定义

​             }

​             public void setId(int id){

​                 this.id = id;//此时的前面的已经代表了类里的实例变量，后面的代表输入的ID值

​             }

​         }

​    this.在实例方法中或者构造方法中，为了区分实例变量和局部变量的情况下不可以省略this.

​         this使用在构造方法中：通过当前的构造方法还可以去调用另一个本类的构造方法，语法格式为

​             public 类名(){

​             this(实际参数列表);//此时this对应的实参的构造方法就会被调用

​             }

​             通过一个构造方法A去调用构造方法B，作用是代码复用，但是前提是两个构造方法是在同一个类当中

​             this()的调用只能出现在构造方法的第一行，且只能出现一次

**10.****如果一个方法直接访问了实例变量，该方法必须是实例方法**

**11.****类体当中有的部分：**

实例变量      实例方法      静态变量      静态方法      构造方法     静态代码块        实例语句块    方法中的局部变量

​         

**第九部分：继承（****extends****）**

​    **1.**子类继承父类时，会将所有包括属性和实例方法等都继承过来，除了构造方法不能继承。但是私有的属性不能在子类中直接访问

​         语法：class 子类类名 extends 父类类名{}

​    **2.****继承的作用：**

​         基本作用：子类继承父类，代码可以得到复用

​         主要作用：只有有了继承关系，才有了方法覆盖和多态机制

​    **3.****继承在****java****中只允许单继承，****C++****可以多继承，但是****java****中可以有间接多继承的效果**

java中的类没有显示的继承任何类时，默认继承Object类，Object类是java提供的根类（老祖宗类），一个对象生而具有Object的所有特征

​    **4.****继承的缺点：**

​         会使得代码的耦合度增强，父类修改，子类就会受到牵连

​    **5.****实际上，等价于将父类的所有除了构造方法的代码复制到子类当中，是将父类继承来的方法归为自己，属于子类自己的方法（继承来的就是自己的）**

​    **6.****什么时候使用继承？**

​         凡是使用“is a”可以描述的，都可以继承。比如Cat is an Animal

​         这时Cat可以为子类，Animal可以为父类

​         假设以后A类和B类都有重复的代码，也未必可以继承，关键判断标准还是是否可以用is a来描述

​    **7.Object****类**

​         Object类中有哪些方法？

​             一些调用C++底层的方法

​             还有一些toString的实例方法

toString();这个方法就是输出一个字符串，将java对象转换成字符串的形式，其中的内容是“类名 + @ + 对象在堆内存中的经过哈希算法的地址”

当直接System.out.println(引用);时，println方法会默认调用"toString"方法，因此其真正代码为System.out.println(引用.toString());

 

**第十部分****:** **方法覆盖和多态**

  **方法覆盖：**

​    1.当子类从父类继承的行为中，有些行为需要改进，例如父类中无法满足子类业务需求的方法，因此需要在子类中进行方法覆盖（方法重写）[Override或者Overwrite]

​    **2.****方法覆盖就是将继承来的方法覆盖掉，子类调用该方法时，一定执行覆盖之后的方法**

​    **3.****如何判断是否方法覆盖？**

​         条件一：两个类一定有继承关系

​         条件二：重写的方法必须和原方法有着相同的返回值类型，相同的方法名，相同的形参列表

​         条件三：访问权限不能更低，可以更高

​         条件四：重写的方法不能比之前的方法抛出更多的异常，可以更少

​    **4.****注意**

​         （1）方法覆盖只是针对方法，和属性无关

​         （2）私有方法无法覆盖，静态方法不谈覆盖

​         （3）构造方法不能被继承，因此也不可以被覆盖

（4）方法覆盖只针对实例方法，静态方法覆盖没有意义,因为多态和方法覆盖是联系关系，因此多态和对象有关，而静态方法执行不需要对象，因此静态方法不存在方法覆盖

​         （5）方法覆盖/重写时，建议直接将父类的方法复制粘贴，防止出错

​    **5.****很多情况下，****toString****方法都是让我们用来重写的**

​    **6.****方法重载和方法覆盖的区别**

​         （1）方法重载发生在同一个类中

​              方法覆盖发生在具有继承关系的父子类中

​         （2）方法重载是一个类中，方法名同，参数列表不同

​              方法覆盖前后的方法的方法名和参数列表和返回值类型都相同

  **多态：**

​    **1.****多态的基础语法**

​         **（****1****）****java****中允许向上转型，也允许向下转型。但无论是向上还是向下转型，两种类型之间必须有继承关系**

​             允许父类型的引用指向子类型的对象，被称为向上转型，即子--->父(自动类型转换)

​             例如:Animal a2 = new Cat(); 是允许的

​             允许子类型的引用指向父类型的对象，被称为向下转型，即父--->子(强制类型转换，需要强制转换符)

​             例如:Cat x = (Cat)a2; 是允许的

​                 何时必须使用向下转型？

​                     当访问的方法时子类中特有的方法时，必须向下转型（强制类型转换）

​                 向下转型是否有风险？

​                     都有风险，如果底层的类和强转的类不一致，就会出现类转换异常

​                     例如：Animal a2 = new Brid(); Cat x = (Cat)a2; 此时就会有以下报错：

​                     java.lang.ClassCastException(类转换异常)

​                 怎么避免类转换异常？

​                     使用instanceof运算符

​                     （1）instanceof可以在运行阶段动态判断引用指向的对象的类型

​                     （2）instanceof的语法：

​                              (引用 instanceof 类型)

​                     （3）instanceof运算符的运算结果只能是 true / false

​                     （4）假设(a2 instanceof Bird)为true(false)，代表a2所指向的对象是（不是）Bird类型的

​             注：没有继承关系，就没有向上和向下转型

​                 程序员应该养成习惯：任何时间，任何地点，对类型进行向下转型时，一定要使用instanceof 运算符进行判断

​                     这是java规范中要求的，这样可以很好的避免类转换异常

​         **（****2****）多态指的是**

​             父类型引用指向子类型对象。

​             包括编译阶段和运行阶段：

​                 编译阶段绑定父类的方法

​                 运行阶段动态绑定子类型对象的方法

​             所以编译和运行是两个不同的状态，是多态的体现

​         **（****3****）多态在开发中的作用**

​             软件在扩展过程中，修改的越少越好，修改的越多，系统稳定性就越差，未知的风险就越多

​             降低程序的耦合度，提高扩展力

​             建议面向抽象编程，不要面向具体编程

​         **（****4****）学习多态后，对于方法覆盖中的****“****相同的返回值类型****”****可以修改吗？**

​                 对于返回值类型为基本数据类型的，覆盖前后必须一致

对于返回值类型为引用数据类型的，重写之后返回值类型可以变得更小（几乎不会使用，直接CV即可，没人这样写）

**第十一部分：****super****关键字：代表当前对象的父类型特征**  

​    **1.this****只能出现在实例方法和构造方法中**

​         语法是this.或者this(),不能用于静态方法中

​         this.大部分可以省略，在区分实例变量和局部变量的时候不能省略

​         this()只能出现在构造方法第一行，调用本类中其他的构造方法中

​     super只能出现在实例方法和构造方法中

语法是super.属性名【访问父类属性】或者super.方法名(实参)【访问父类方法】或者super(实参)【调用父类的构造方法】,不能用于静态方法中

​         super.大部分可以省略

​         super()只能出现在构造方法第一行，调用父类中其他的构造方法中，目的是创建子类对象时先初始化父类特征

​    **2.super()****表示通过子类的构造方法调用父类的构造方法，模拟现实世界中有儿子的前提是有父亲**

因此在子类中的构造方法第一行如果什么都没写的话系统会自动加一个super();来调用父类中的无参构造方法，如果父类中没有

当一个构造方法第一行既没有this()又没有super()时，默认会有一个super()，表示当前的子类的构造方法调用父类的无参数构造方法，因此此时必须保证父类的无参数构造方法是存在的

​         而当子类中出现例如super(123)的语句时，代表调用父类中有int型参数的构造方法

​         对super的调用必须是在构造方法中的第一个语句，因此this()与super()不可以共存

​             若什么也没有，就是默认有super()。如果有this(),那么调用的this()里面也会有super();

​    **3.****在****java****中不论****new****什么对象，****Object****的无参构造方法一定会执行，其（构造方法）一定处于栈的顶部，最后调用，最先结束**

​    **4.****使用****super(****参数列表****)****的时机：**

想要用在子类的构造方法中输入的实参来给父类中private修饰的属性赋初始值时应该用super来使得父类中的私有属性在本类中被初始化

**5.****虽然在构造方法执行过程中一连串地调用了父类的构造方法，父类的构造方法又向下调用了它的父类的构造方法，但是实际上对象只创建了一个**

​    6**.super(****实参****)****的作用****:**

初始化当前对象的父类型特征，并不是创建新对象

​    **7.super****关键字代表什么？**

​         代表的就是“当前对象”的那部分父类型特征，super是this指向的那个对象中的一块空间

​    **8.super.****什么时候不可以省略？**

​         java中允许在子类中出现和父类一样的同名变量/同名属性

​         若子类和父类中有同名属性或者相同的方法，且需要在子类中访问父类的数据，此时的super.不可以省略

​             例如：this.name 访问的是当前对象的name属性

​                  super.name 访问的是当前对象父类型特征的name属性 super.move(); 表示访问父类中的move方法

​                  注：用super.访问父类的私有数据是没有权限的

​    **9.super****不是引用，也不保存内存地址。也不指向任何对象，它只是代表当前对象内部的那一块父类型的特征**

​         this和super都不能用在静态方法中，主方法当然也不行

​         

​    



 

## Part two

**第一部分** **集成开发环境****------IDEA**

​    **1.****所有的****java****开发环境** **eclipse****、****intellij IDEA****等**

​    **2.idea****的快捷键以及简单的设置**

​         字体设置：file---->settings---->font

​         快捷写出main方法：直接写出main再回车

​         快捷写出System.out.println();  sout即可

​         idea设计自动保存，不需要手动ctrl s

​         Ctrl y 是删除一行

​         代码上右键run或者点击左边的绿色光标

​    **3.idea****中退出任何窗口，都可用****esc****键**

​    **4.****任何新增、新建、添加都是****insert + alt**

​    **5.****窗口变大变小是****ctrl + shift + F12**

​    **6.** **单行注释时****Ctrl + /**

​      **多行注释时****Ctrl + shife + /**

​    **7.idea****中怎么定位某个方法****/****属性****/****变量？**

​      光标停留在某个单词下面，这个单词可能是方法名、变量名

​      停到下面后，按住Ctrl键会出现下划线，此时再点击就会跳转

​    **8.idea** **中****Ctrl + d** **是复制一行**

​    **9.****纠错快捷键** **alt +** **回车**

​    **10.****按住****alt****键可以多行同写**

 

**第二部分** **面向对象**

  **1.final****关键字**

​    （1）final可以修饰变量、方法、类等，表示最终的，不可变的

​      若你不想某个类能够被继承，那么你可以在这个类的前面加一个final

​    （2）final修饰的类？

​      final在前的类是最终类，不可以被继承

​    （3）final修饰的方法？

​      被final修饰的方法不能被覆盖重写，与是否可以被调用没有任何关系

​      即public final void xxx(){} 的方法不可以被重写

​    （4）final修饰的变量？//final修饰的变量能且只能赋值一次

​      final修饰的局部变量，一旦被第一次赋值，就不在允许第二次赋值了，也即不允许重新赋值

​      而成员变量有初始值，而局部变量没有初始值

因此当final修饰实例变量时，java将不会再赋默认值，必须程序员手动赋值，赋值可以在变量后面直接赋值，也可以在构造方法里赋值（因为系统给实例变量赋默认值是在构造方法中赋值）

实例变量的缺点就是浪费内存空间，当实例变量使用final修饰时，说明该实例变量的值不会随着对象的变化而变化，因此往往final修饰的实例变量一般添加static修饰，变成静态的，放于方法区，节省内存

​      **终极结论：****static final****联合修饰的变量叫做****“****常量****”****，常量名建议全部大写，每个单词之间用下划线衔接**

​        实际上，常量和静态变量一样，只是常量的值不能变，无法重新赋值

​        常量一般格式：

​          public static final xxx xxx = xxx;

​          常量是公开的原因是不可修改的，即使公开也没关系

​    （5）final修饰的引用？

引用同样也是变量，因此被final修饰的引用只能指向一个对象的内存地址，并永远指向该对象，再给它一个新的new的对象的地址是无法赋值的

​      但是final修饰的引用指向的对象其中的数据仍然可以修改

​      null同样无法赋值;

​      当有一个引用指向某个对象时，该对象不会被垃圾回收器回收，直到当前方法结束才会释放空间

  **2.****抽象类**

​    （1）什么是抽象类？

​      类和类之间有共同特征，将这些具有共同特征的类再进一步抽象形成了抽象类，由于类本身是不存在的，所以抽象类无法创建对象

​      抽象类与抽象类之间可能还有共同特征，还可以进一步再抽象（类到对象是实例化，对象到类是抽象）

​    （2）抽象类也属于引用数据类型，语法是

​        [修饰符列表] abstract class 类名{

​          类体;

​        }

​    (3)抽象类无法创建对象，也即无法new对象,是无法实例化的，因此我们理解

​      抽象类是天生用来被子类继承的,也因此abstract 和 final不能联合使用，这两个关键字是对立的

​    （4）抽象类的子类可以还是抽象类,抽象类虽然不能实例化，但是抽象类还有构造方法，是供子类使用以让其实例对象

​    （5）什么是抽象方法？

​      表示没有实现的方法，也即没有方法体的方法

​        例如：public abstract void doSome();这里没有大括号

​      特点：1.没有方法体，以分号结尾 2.前面修饰符列表中有abstract关键字

​    （6）抽象类中不一定有抽象方法，但是抽象方法必须出现在抽象类中

​    （7）一个非抽象类继承抽象类时，必须将父类中继承来的抽象方法通过覆盖或者重写来将其实现，java中语法强行规定的

​      而抽象类继承抽象类时，则不必要一定将父类中的抽象方法实现

​    （8）Object类中有许多方法都没有方法体，但是他们不是抽象方法，他们调用了底层的C++代码，因此并不是没有方法体的方法都是抽象方法

  **3.****接口**

​    **1.****接口的基础语法**

​      （1）接口也是一种引用数据类型

​      （2）接口是完全抽象的，抽象类是半抽象的，或者说接口是特殊的抽象类，因此接口也不能new对象

​      （3）接口怎么定义？

​          语法

​          [修饰符列表] interface 接口名{}

​      （4）接口编译以后依旧是一个class字节码文件

​      （5）接口可以继承，并且接口和接口之间、类和接口之间还支持多继承，这个机制弥补了java中的单继承缺陷

​      （6）接口里只包含两部分内容：常量和抽象方法，没有其他内容了，因此接口中的方法不能有方法体

​          因此接口中所有的元素都是public公开的，在定义抽象方法时，public abstract可以省略不写

​            在定义常量时，public static final可以省略不写

​          接口中随便写一个变量就是常量，是值不可以改变的变量

​      （7）类和类之间叫做继承，类和接口之间叫做实现，可以将实现“当做”继承，继承使用extends关键字，而实现使用implements关键字

​      （8）当一个非抽象的类实现（继承）接口时，必须要将接口中所有的抽象方法全部实现（覆盖重写）

​      （9）使用接口也可以面向接口编程，也是多态的体现

​      （10）接口A和接口B虽然没有继承关系，但是写代码的时候，可以互转，编译可以通过，但是运行时可能出现classCastException异常

​          如果想要用其他接口中独有的方法，需要接口转型，因此向下转型时先if（instanceof）

​      （11）当一个类既有继承、又有接口时，应该先把extends写在前面，implements写在后面，能插能拔的就是接口，接口通常提取的是行为动作

​    **2.****接口在开发的作用（略微类似多态在开发中的作用）**

​      （1）凡是能够用has a 来描述的，都以属性存在

​      （2）面向接口编程可以低耦合，高扩展

​      （3）接口的使用离不开多态，只有接口和多态结合起来才可以低耦合高扩展

​      （4）接口可以解开耦合，解开的是调用者和实现者之间的耦合，调用者面向接口调用，实现者面向接口编写实现

​    **3.****类与类之间的关系** **is a ; has a ; like a**

​      Cat is a animal 凡是可以满足is a 的，都是继承关系 A extends B

​      Customer has a menu 凡是可以满足has a 的，都是关联关系，以属性的形式存在 A {B b}

​      Cook like a FoodMenu （厨师像菜单一样） 凡是可以满足 like a 的，都是实现关系，以类实现接口存在 A implements B

  **4.****抽象类和接口有什么区别**

​    抽象类是半抽象，接口时完全抽象

​    抽象类中有构造方法，接口中没有构造方法

​    接口与接口之间支持多继承，类和类之间只能单继承

​    一个类可以同时实现多个接口，一个抽象类只能继承一个类

​    接口中只允许出现常量和抽象方法

​      以后接口使用的比抽象类多，一般抽象类用的少

​    接口一般是对行为的抽象，而抽象类既可以抽象行为，又可以抽象数据

​    字符串都是对象，不用new就是对象

 

**第三部分** **包机制和访问权限**

  **1.****包机制** **import and package**

​    （1）为什么使用package？

​      package是java中的包机制，其作用是方便程序的管理

​      不同功能的类分别存放在不同的包下（按照功能分类）

​    （2）package怎么使用？

​      package是一个关键字，后面加一个包名

​        例如 package com.bjpowernode.javase.chapter17;

​      注意：package语句只允许出现在java源代码中的第一行（注释不算行）

​    （3）包名的命名规范？

​      一般采用公司域名倒序的方式

​        因为公司域名具有全球唯一性

​      规范：

​        公司域名倒叙 + 项目名 + 模块名 + 功能名

​    （4）带有package的java程序怎么编译和运行？

​      加了包代码后，类名将会发生改变，变成了com.bjpowernode.javase.chapter17.原类名

​      也即四个文件夹嵌套后再放入class文件才是类名

​      编译：

​        cmd中 javac -d . xxxxx.java

​          javac 负责编译的命令

​          -d  带包编译

​          .   代表编译后生成的东西放到当前目录下

​      运行：

​        java com.bjpowernode.javase.chapter17.原类名

​    （5）如果在com.bjpowernode.javase.chapter17目录下还有其他java源代码想要new对象，可以

​        com.bjpowernode.javase.chapter17.原类名 s = new com.bjpowernode.javase.chapter17.原类名();

​      而当两者都在同一个包下，包名可以省略，不在同一个包下不可以省略

​    （6）import的意思是导包，将提到的类给导入到当前目录下

​      import什么时候用？

​        A类中使用B类，若两者都在一个包下，则不需import。

​        若两者不在同一个包下，则需要import

​      import怎么用？

​        import只能出现在package语句之下，class声明语句之上

​        例如java.util.Scanner 中java.util 就是Scanner的包名，Scanner是类名

​        如果在前面加上import java.util.Scanner 或者 java.util.* ,此时的代码只需写 Scanner s = new Scanner();

​      java.lang.*; 这个包下面的类不需要导入，不需要import

 

**第四部分** **访问控制权限**

  1.一共有四种访问权限

​    私有的   private

​    受保护的  protected

​    公开的   public

​    默认

​    以上四个访问控制权限控制范围是:

​    private   是私有的，只能在本类中访问

​    public   表示公开的，在任何时候都可以访问

​    protected  表示只能在本类、同包以及子类中访问

​    默认    表示只能在本类以及同包下访问

 

  \2. 访问控制修饰符   本类   同包   子类   任意位置

​    public      可以   可以   可以   可以

​    默认       可以   可以   不行    不行

​    private     可以   不行   不行   不行

​    范围 public > protected > 默认 > private

  3.访问控制修饰符可以修饰什么？

​    属性（四个都可以用）

​    方法（四个都可以用）

​    类 (只能用public 和 默认)

​    接口（只能用public 和 默认)

​    ....

 

**第五部分** **Object****类**

  **1.Object****中常用的方法？**

​    （1）找方法的路径:

​      1.源代码

​      2.去查阅java的类库的帮助文档

​    （2）什么是API？

​      应用程序编程接口（application program interface）

​      整个JDk的类库就是javase的API

​      每一个API都会配置一套API帮助文档

​    （3）目前只需要知道一下方法

​      protected Object clone()          负责对象克隆

​      int hashCode()                 获得对象哈希值的方法

​      boolean equals(Object obj)        判断两个对象是否相等

​      protected void finalize()      垃圾回收器负责调用的方法

​      String toString()               将对象转换成字符串

​    （4）toString方法

​        源代码中toString方法的默认实现是

​          类名@对象的内存地址转换为十六进制的形式

​        toString方法的目的？

​          通过调用这个方法，可以将一个java对象转换成字符串表示形式

​          建议所有子类都重写这个toString方法，向着简洁的，详实的，易于阅读的方式去写

​        输出引用时直接默认输出引用的toString方法

​         toString方法以后都需要重写

​          public String toString(){}

​    （5）equals方法

​         equals方法的目的？

​          通过调用这个方法，可以判断两个对象是否相等

​          判断两个基本数据类型是否相等可以用 == ，但是两个对象（引用数据类型）的判断如果用 == 比较的是两个对象之间的地址是否相等

​          因此两个双等号不可以比较两个对象是否相等，因为我们要判断的是对象的内容是否相等

​          在Object类中默认采用双等号来判断两个对象是否相等，判断的是内存地址，因此Object中的equals是不够用的，因此我们需要在子类中重写这个方法

​         怎么重写equals方法？

​          public boolean equals(Object obj){}

​         java中的String类也重写了toString方法和equals方法

​          由于String也是一个类，因此比较两个字符串的时候也不能用双等号，因为双等号是比较内存地址。

​          必须调用equals方法来比较

​            例如：比较String s1 = "Test01";       应该用方法：

​                String s2 = "Test01";        s2.equals(s1);//true

​                                  s1 == s2;//false

​         java中什么类型的数据用双等号判断相等？什么类型的数据用equals判断相等？

​          规定：

​          基本数据类型用 ==

​           对象也即引用数据类型用 equals()

​         equals方法重写要彻底,尽量做到每个方法都重写equals犯方法

​    （6）finalize方法

​        这个方法时protected修饰的，在Object类中的源代码是

​          protected void finalize() throws Throwable{}  只有一个方法体，没有代码

​        这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法

​        finalize的执行时机：

​          当一个java对象即将被垃圾回收器回收时，垃圾回收器负责调用这个方法

​        这个方法实际上是SUN公司为java程序员准备的一个时机，即垃圾销毁时机。如果希望在对象销毁时机执行一段代码的话，这段代码要写到这个方法中

​        静态代码块在类加载时执行且只执行一次，这是SUN准备的类加载时机；而finalize方法也是SUN准备的时机，是垃圾回收时机

​        finalize只需要重写，之后会有GC会自动调用，不像以上提到的方法需要程序员手动调用

​        提示：java中的垃圾回收器不是轻易启动的，垃圾太少或者时间没到，有可能启动或者不启动

​          用这段代码可以建议垃圾回收器启动，可能不听建议：System.gc(); 静态方法，启动的概率变大了

​    （7）hashCode方法

​        源代码：public native int hashCode();

​          这个方法不是抽象方法，带有native分、关键字，底层调用C++程序

​        hashCode返回的是哈希值，实际上就是一个java对象的内存地址，经过哈希算法得出的一个值，因此其执行结果可以等同于一个java对象的内存地址

 

**第六部分** **匿名内部类**

  **1.****什么是内部类？**

​    在类的内部又定义了一个新的类，叫做内部类

  **2.****内部类的分类？**

​    静态内部类：类似于静态变量  static class{}

​    实例内部类：类似于实例变量  class{} 在类体中

​    局部内部类：类似于局部变量  class{} 在方法中

  **3.****匿名内部类是局部内部类的一种，它没有名字，所以叫做匿名内部类**

  **4.****匿名内部类是可以直接****new****接口，但是需要在****new****的****()****后面加上大括号，直接加上实现的方法**

​    例如：new compute(){

​      public int sum{

​        return a + b;

​      }

​    }

​    其中

​           { public int sum{

​             return a + b;

​           }}

​    就是匿名内部类

  **5.****不建议使用匿名内部类，因为一个类没有名字是不可以重复使用的，同时代码太乱，可读性太差**

**6.****学习匿名内部类的原因是装逼好用**

 

**第七部分** **数组**

  **1.****数组概述**

​    （1）java中的数组是引用数据类型，不是基本数据类型，其父类是Object

​    （2）数组实际上是一个容器，可以同时容纳多个元素，是一个数据的集合

​    （3）数组可以存储基本数据类型，也可以存储引用数据类型

​    （4）由于数组是引用类型，所以数组对象存放在堆内存中

​    （5）数组中如果存储的是java对象的话，实际上存储的是对象的“引用(内存地址)”

​    （6）数组一旦创建，在java中规定，数组长度不可变

​    （7）数组的分类：一维数组、二维数组、三维数组、多维数组。。。。

​    （8）所有的数组对象都有Length属性！（java自带的），用来获取数组中元素的个数

​    （9）java中的数组要求数组的类型统一，比如int类型的数组只能存储int类型的数据

​    （10）数组在内存方面存储时，内存地址（存储的每一个元素都是有规则的挨着排列的）是连续的，内存地址连续

​        这是数组存储元素的特色，数组实际上是一种简单的数据结构

​    （11）所有的数组都是拿第一个小方框的内存地址作为整个数组对象的内存地址（因为地址是连续的），数组的内存地址就是第一个元素的内存地址

​    （12）数组的优点和缺点

​        优点：查询/查找/检索某个下标上的元素时效率极高，可以说是查询效率最高的一个数据结构

​          为什么检索效率高？

​            1.每个元素的内存地址是连续的

​            2.每个元素的类型一样，占用的空间一样

​             3.知道一个元素的内存地址，一个元素的占用空间，就可以用数学表达式算出某个下标上元素的内存地址来定位元素

​            4.正因为数组查找数据不是一个一个找的，而是通过数学表达式算出来的，因此存储100个和1000000个数据的检索效率是一样的

​        缺点：1.由于为了保证每个元素的地址连续，所以在数组上随机删除或者增加元素的时候，效率低。因为此时会涉及到后面元素向后或者向前位移的操作

​              注：对数组中最后一个元素增删是没有影响的

​           2.数组不能存储大数据量，因为很难在内存空间上找到一块很大而连续的内存空间

​    （13）数组中所有的元素都有下标，第n个元素的下标是n-1; n就是Length;

​        下标非常重要，对数组中元素进行存取的时候都需要下标

  **2.****一维数组的初始化**

​    定义/声明语法格式：

​      int[] array1;       double[] array2;      boolean[] array3;      String[] array4;

​    **初始化方式****:**

​      1.静态初始化：已经确定数组中有哪些具体元素

​        int[] array = {100,2100,300,55};

​      2.动态初始化：不确定数组中有哪些具体元素，是用来为元素预分配空间

​        int[] array = new int[5];

​          这里的5代表的是array数组中的元素个数，即Length为5，此时5个元素的默认值为0；

​          默认值还是和原先的规则一致

  **3.****一维数组的访问** **已知** **int a = {...}**

​    数组元素的个数

​      a.length

​    第一个元素

​      a[0]

​    最后一个元素

​      a[a.length - 1]

​    若数组的元素越界（）只有n个元素却要访问n+1个元素

​      ArrayIndexOutOfBoundsException（数组越界异常）

  **4.****当方法的参数是数组时，可以**

​    1.将数组赋给变量，用变量名

​    2.(new int[4])     动态数组

​    3.(new int[]{1,2,3,4}) 静态数组

  **5.main****方法中的****String[] args****有什么用？**

​    main方法是程序员负责写，JVM负责调用，调用时会自动传入一个String类型的数组，这个数组的默认长度是0，也即args不是null

​    也即创建了args数组对象，但是里面没有东西，只有一个{}

​      其实这个数组时留给用户的，用户可以在控制台上输入参数，这个参数自动会转换为String[] args

​        例如：在cmd中运行 java 类名 ABC def faj

​          此时JVM会自动将ABC def faj通过空格的方式进行分离，分离完成后，自动放到String[] args数组中{"ABC","def","faj"}

​          因此String[] args是用来接收用户输入的参数的

  **6.****一维数组的扩容**

​    java中数组的长度不可变化，如果满了，就需要扩容

​    java中对数组的扩容是：

​      先新建一个大容量的数组，然后将小容量的数组中的数据一个一个的复制到大容量的数组中

​      因此数组扩容效率较低，涉及到拷贝的问题。因此尽可能少地进行数组的拷贝

​    拷贝语法（基本和引用数据类型都可以拷贝）

​      直接写System.arraycopy(源数组，源数组开始拷贝的下标，拷贝目标数组，目标数组开始接收拷贝的下标，拷贝的数据个数长度);

​      这是个静态方法，这个方法在System类里

​    能不拷贝就不拷贝扩容

  **7.****二维数组**

​    二维数组其实是特殊的一维数组，特殊在这个一维数组的每个元素都是一维数组

  **8.****二维数组的初始化**

​    静态初始化：

​       int a[][] = {{10,20,30},{100,200},{1,2,3,4},{1}} 或者

​      int [][] a = {{10,20,30},{100,200},{1,2,3,4},{1}}

​      此时a.length == 4,  a[0].length == 3

​    动态初始化:

​      int a[][] = new int[3][4];

  **9.****常见的算法**

​    **排序算法**

​       **冒泡排序算法**

​        每一次循环结束后，都要找出最大的数据，放到参与比较的这堆数据的最右边，也即冒出最大的那个气泡

​        核心是拿着左边的数字和右边的数字进行比对，当左边 > 右边时，交换位置

​        int[] arr = {3,2,5,7,7,10,235,13,4356,13,576,78,8};

​            for (int i = 0; i < arr.length - 1; i++) {       //循环arr.length -1 次

​              for(int j = 0;j < arr.length - 1 - i;j++){     //里面比较 arr.length - 1 - i 次

​                if(arr[j] > arr[j+1]){

​                  int temp = arr[j+1];            //交换数据位置

​                  arr[j+1] = arr[j];

​                  arr[j] = temp;

​                }

​              }

​            }

 

​      **选择排序算法**

​         每一次从参与比较的这堆数据中找到最小值，拿这个最小值和最前面的元素交换位置

​        int[] a = {1,34,56,2,4,6,34,3};

​            for (int i = 0; i < a.length; i++) {

​              int min = i;

​              for(int j = i + 1;j < a.length;j++){

​                if(a[min] > a[j])

​                  min = j;      //此时的方法很是巧妙，可以直接比较大小而更改下标，不要用min当做最小数进行比较

​              }

​              int temp;

​              temp = a[min];

​              a[min] = a[i];

​              a[i] = temp;

​            }

​      **堆排序**

​    **查找算法**

​      普通查找：一个又一个的查找，找到为止

​      **二分法查找**

​        只适用于已经排好序的数据，未排序的数据无法查找，其查找的效率要高于“一个挨着一个”查找的

​        int[] a = {3, 4, 6, 9, 92, 100};

​            int begin = 0;                     //开始下标

​            int end = a.length - 1;                 //末尾下标

​            int dest = 100;                      //目标数据

​            while (begin <= end) {

​              int mid = (begin + end) / 2;            //中间下标

​              if (a[mid] == dest) {

​                System.out.println("下标是" + mid);

​                return;

​              }

​              if (a[mid] > dest) {                 //目标在左边

​                end = mid - 1;

​              }

​              if(a[mid] < dest) {                 //目标在右边

​                begin = mid + 1;

​              }

​            }

​    其中java里有一个java.util.Arrays

​      **Arrays****是一个工具类，其中有一个****sort()****方法，可以排序。**

​      **这些是静态方法，直接使用类名调用即可。工具类中的方法基本都是静态的**

 

**第八部分** **常用类**

  **1.String****类**

​    （1）String是字符串，属于引用数据类型

​    （2）在java中随意用双引号括起来的都是String对象

​    （3）java中规定，用双引号括起来的字符串是不可变的，因为String源代码中有一个byte数组，而这个数组是被final修饰的

​    （4）在JDK中双引号括起来的字符串，例如“abc”都是直接存储在“方法区“的”字符串常量池“中的，原因是字符串在开发中太常用了

​    （5）String s1 = "abc"; s1里保存的不是"abc"字符串，而是其字符串对象的内存地址

​    （6）而new String时会在堆里开辟一个空间，这个空间里存储着指向字符串常量值中的地址

​    （7）如果常量池中已经有"Hello"时，再去创建一个"Hello"时不会再重新新建一个了，会共用一个地址

​    （8）垃圾回收器不会释放常量池里面的字符串的

​    （9）字符串比较必须使用equals方法，String类已经重写了equals方法。双等号不保险.而且String类也重写了toString方法，输出字符串本身

​    （10）String中常用的构造方法

​      1.String s1 = "abc";

​      2.byte[] a = {97,98,99};//ascii码中为a，b，c

​       String s2 = new String(a); //输出abc

​      3.char[] chars = {'a','b','c'};

​       String s4 = new String(chars);//输出abc

​      4.String s3 = new String(字节数组a,数组元素下标的起始位置,长度);

​       String s3 = new String(chars,1,2);//输出bc

​        注：字节数组也可以换成byte数组

​      5.String s5 = new String("sfkaa");

​    （11）System.out.println实际上第一步都是将内容转换成字符串，只有字符串才能打印到控制台上

​    （12）String类中的常用方法

​      1.char charAt(int index)

​        例子:输出字符串中的单个字符

​          char c = "abc".charAt(1);

​          System.out.println(c);//输出b

​      2.int compareTo(String anotherString)

​        例子:按照字典的顺序比较两个字符串大小

​          int result = "abc".compareTo("abc");

​          System.out.println(result);//前后输出0，前小后大输出-1，前大后小输出1

​      3.boolean contains(CharSequence s)

​        例子:判断前面的字符串是否包含后面的字符串

​          "HelloWorld".contains("Hello");//返回true

​      4.boolean endWith(String suffix)

​        例子:判断当前字符串是否以某个字符串结尾

​           "text.txt".endWith("txt");//返回true

​      5.equals

​      6.boolean equalsIgnoreCase(String anotherString);

​        例子:在忽略大小写的前提下判断两个字符串是否相等

​          "ABc".equalsIgnoreCase("abC");//return true;

​      7.byte[] getBytes()

​        例子:将字符串对象转换成字节数组

​          "abcd".getBytes();//return byte[]={97,98,99,100};

​      8.int indexOf(String str)

​        例子:判断某个子字符串在当前字符串中第一次出现的下标（索引）

​          "abcdabcd".indexOf("abc");//return 0;

​      9.boolean isEmpty()

​        例子:判断某个字符串是否为空.底层调用了字符串的length()方法

​          "".isEmpty();// return true;

​      10.int length()

​        例子:判断字符串的长度

​        注意：判断数组长度是length属性，判断字符串长度是length()方法

​          "abc".length();//return 3;

​      11.String replace(CharSequence target,CharSequence replacement)

​        例子:String的父接口就是CharSequence

​           "fudan.edu.cn".replace("fudan","jiaoda");//return "jiaoda.edu.cn"

​      12.String[] split(String regex)

​        例子:以某个位置为分隔符拆分字符串

​           "1960-10-24".split("-")//return String[]={"1980","10","24"};

​      13.boolean startWith(String prefix)

​        例子:判断某个字符串是否以某个字符串开始

​          "fudan.edu.cn".startWith("fudan")//return true;

​      14.String subString(int beginIndex)

​        例子:截取字符串,参数是起始下标

​          "fudan.edu.cn".subString(6)//return "edu.cn";

​      15.String subString(int beginIndex,int endIndex)

​        例子:截取字符串，参数是起始和终止下标，但是包含起始下标，不包含终止下标

​          "fudan.edu.cn".subString(6,9)//return "edu";

​      16.char[] toCharArray()

​        例子: 将字符串转换成char数组

​          char[] c = "abc".toCharArray()//return c = {'a','b','c'};

​      17.String toLowerCase()

​        例子:转换为小写

​        注：toUpperCase() 与之对应，其作用是转换为大写

​          "ABC".toLowerCase()//return "abc";

​      18.String trim()

​        例子:去除字符串前后空白

​          "   hello  world  ".trim()//return "hello  world";

​      19.static String valueOf(各种类型)

​        例子:将非字符串转换成字符串

​        注：这是String类中唯一的静态方法，当参数为对象时，会调用toString()方法来输出字符串

  **2.StringBuffer and StringBuilder**

​    （1）在使用"+"对字符串拼接时，由于java中的字符串是不可变的，因此每一次拼接都会产生新的字符串，这样

​      会占用大量的方法区内存，造成内存空间的浪费，给字符串常量值带来较大的压力

​    （2）如果要进行大量的字符串拼接，必须使用StringBuffer中的append方法

​    （3）通过StringBuffer s = new StringBuffer();

​        来创建出一个默认长度为16的字符串缓冲区，其底层是16个长度的char数组，其没有被final修饰

​       然后通过调用append方法来进行拼接，当长度不够时会自动通过System.arrayCopy()数组拷贝进行数组扩容，不会产生新对象，因为旧数组会被GC释放掉

​        s.append(true);

​        s.append(3.12);

​        s.append(100);

​        System.out.println(s);//return true3.12100

​    （4）如何优化StringBuffer的性能？

​         在创建StringBuffer的时候尽可能给定一个初始化容量(int 型参数)，最好减少底层数组的扩容次数，预估一下给出大一点的初始化容量

​    （5）StringBuffer和StringBuilder都可以对String进行拼接，两者的唯一区别是：

​        StringBuffer中的方法都有synchronized关键字，而StringBuilder没有，表示前者是线程安全的，而后者的线程不安全

  **3.****八个包装类**

​    （1）java中为8种基本数据类型又准备了8种包装类型，8种包装类属于引用数据类型，父类是Object

​    （2）为什么提供8中包装类？

​        因为8种基本数据类型不够用，有些方法需要使用Object对象，所以Sun又提供了8种包装类型，都是引用数据类型，都继承Object

​    （3）8种基本数据类型对应的包装类名是什么？

​        基本数据类型       包装类型

​        byte          java.lang.Byte   父类（Number）

​        short          java.lang.Short   父类（Number）

​        int           java.lang.Integer  父类（Number）

​        long          java.lang.Long   父类（Number）

​        float          java.lang.Float   父类（Number）  类名都是java.lang后面的东西

​        double         java.lang.Double  父类（Number）

​        boolean         java.lang.Boolean  父类（Object）

​        char          java.lang.Character 父类（Object）

​    （4）number类是一个抽象类，无法new对象

​      其中有方法

​      byte byteValue() 以byte形式返回指定的数值

​      ...

​      short shortValue() 以short形式返回指定的值

​      这些方法其实所有的数字包装类的子类都有，是负责拆箱的

​      装箱：将基本数据类型转换为引用数据类型  通过构造方法传入参数装箱

​      拆箱：将引用数据类型转换为基本数据类型  通过number中的方法来拆箱

​    （4）java.lang.Integer

​      构造方法中的参数既可以是int型，也可以是"int"有双引号的int数值

​      Integer中可以访问包装类的常量来获取最大值与最小值

​        例如:

​          int的最大值 Integer.MAX_VALUE

​          int的最小值 Integer.MIN_VALUE

​    （5）在JDK1.5以后，支持自动拆箱和装箱了，方便编程

​        自动装箱(基本数据类型自动转换成包装类)： Integer i = 100;

​        自动拆箱(包装类自动转换为基本数据类型)： int x = i;

​        自动拆箱(包装类自动转换为基本数据类型)： int x = i;

​        只有 + - * / 这几个运算会出发自动拆箱机制，== 不会自动拆箱

​    （6）java中为了提高程序的效率，将-128到127之间的整数的包装对象提前创建好，放到了一个方法区的“常量池”中了。

​        目的是只要用这个区间的数据，就不需要再new了，只需要直接从常量池中取出来就可以了(static final就是常量池)

​        因此：Integer a = 100;

​          Integer b = 100;

​           a == b;// true

 

​          Integer a = 128;

​          Integer b = 128;

​          a == b;// false

​        这种做法是将数据放于缓存，提高效率

​          缓存的优点：效率高

​          缓存的缺点：耗费内存

​           大型项目中的重要优化手段就是cache缓存机制

​    （7）Integer类中的方法

​          给Integer构造时，如果用Integer i = new Integer("一二三");//字符串必须是数字

​            会报错：java.lang.NumberFormatException

​         \1. static int parseInt(String s){}

​            静态方法，传参String，返回Int

​            也即s内容必须是数字，比如"100","128340",如果不是数字，比如"一二三",就会出现NumberFormatException异常

​          static double parseDouble(String s){}

​          static float parseFloat(String s){}

​          以上都是静态方法，需要用类名去调用，例如 Double.parseDouble(),Integer.parseInt()

​         \2. static String toBinaryString(int i){}  十进制转换为二进制字符串

​          static String toHexString(int i){}   十进制转换为十六进制字符串

​          static String toOctalString(int i){}  十进制转换为八进制字符串

​          都用Integer.toxxxString(int i){}调用

​         \3. static Integer valueOf(int i){} 将int转换为Integer类型

​          static Integer valueOf(String s){} 将String转换为Integer类型

​    （8）已经学习到的异常

​         空指针异常：NullPointerException

​        类型转换异常：ClassCastException

​        数组越界异常：ArrayIndexOutOfBoundsException

​    （9）int、String、Integer的相互转换

​      1.int--->String  int i;

​        "数字"

​        数字 + ""

​         String.valueOf(i)

​      2.String--->int  String s = "123";

​        Integer.parseInt(s)

​      3.int--->Integer  Integer--->int

​        自动拆装箱

​        Integer.valueOf(i)

​        intValue()

​      4.String--->Integer

​        Integer.valueOf(s)

​      5.Integer--->String

​        String.valueOf(Integer对象)

​       这两个转换用各自的valueOf方法

  **4.java****中的日期类**

​    （1）获取当前系统的时间

​      导包java.util.Date后，直接用构造方法

​          Date nowTime = new Date();

​          System.out.println(nowTime);

​      即输出当前时间，toString方法已经被重写过了

​    （2）怎么将日期格式转换成一定格式的输出方式？怎么格式化

​      SimpleDateFormat是在java.text包下的，专门负责日期的格式化

​      一般在构造方法中给出时间显示结构

​        yyyy 年

​         MM  月

​        dd  日

​        HH  时

​        mm  分

​        ss  秒

​        SSS 毫秒

​        除了他们不可以更改，其他的可以随意更改

​        例如：

​         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

​            再使用SimpleDateFormat中的实例方法format()来关联一个Date对象，返回一个String类型数据

​            System.out.println(sdf.format(nowTime));    //2020-07-29 19:44:48

​    （3）怎么将日期字符串转换成Date类型

​          String time = "2001-10-24 08:08:08";

​          SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//此时的格式需要与字符串一致

​          //如果格式不同会出现异常java.text.ParseException

​          System.out.println(sdf2.parse(time));//需要使用SimpleDateFormat中的实例方法parse()

​          但是此时需要在main法方法入口处加入throws Exception

​    （4）获取自1970年1月1日至今的总毫秒数

​        System.currentTimeMillis();返回的是long类型数据，每过一秒会加1000

​      统计一个方法执行所需要的时间

​        在执行目标方法前记录一个毫秒数

​        在执行目标方法后记录一个毫秒数

​        然后利用前面的总毫秒数相减既是所求数据

​    （5）用从1970年1月1日开始到现在的总毫秒数构造Date对象

​       Date d = new Date(1596025949204L);

​        System.out.println(d);// Wed Jul 29 20:32:29 CST 2020

  **5.java****中的数字类**

​    （1）关于数字的格式化

​      java.text.DecimalFormat是专门负责数字格式化的

​    （2）数字格式有哪些

​      \# 代表任意数字

​      , 代表千分位

​      . 代表小数点

​      0 代表不够时补0

​    （3）举例

​      DecimalFormat df = new DecimalFormat("##,###.###");

​      //表示加入千分位，有几位写几位小数，最多保留三位小数

​      String s = df.format(123445); //123,445

 

​      DecimalFormat df = new DecimalFormat("##,###.000");

​      String s = df.format(123445); //123,445.000

​    （4）BigDecimal 属于大数据，精度极高，不属于基本数据类型，属于java对象，也即引用数据类型，这是SUN提供的一个类，

​        专门用于财务软件当中，因为double在财务中是不够用的，它是属于java.math.BigDecimal包下

​        BigDecimal b1 = new BigDecimal(100);

​        BigDecimal b2 = new BigDecimal(200);

​        两者相加不是简单的b1+b2，因为其为引用数据类型，因此需要调用方法

​        BigDecimal b3 = b1.add(b2);//调用方法来求和

​        System.out.println(b3);//300

​    （5）随机数的生成

​        Random r = new Random();      //创建随机数对象

​        int num = r.nextInt();       //随机产生一个int范围的随机数，并赋值给num变量

​        System.out.println(num);

​        int num = r.nextInt(int i);     //在0 - i-1之间随机产生一个随机数，但是不能产生i

  **6.****枚举**

​    结果有两种情况的建议用布尔类型，如果结果超过两种并且一枚一枚可以列举出来的才建议用枚举

​    定义语法：

​      enum 枚举类型名{

​        各枚举值之间用逗号隔开，并且字母全部大写

​        每个枚举值都是枚举类型值类型中的一个值

​      }

​    枚举编译以后也是class文件，枚举类型名第一个字母需要大写，枚举也是一种引用数据类型，枚举中的每个值可以看做常量，但是不可以赋值，只写英文字母即可

​    需要注意enum声明时不能在各个方法里包括主方法中声明，需要在类体中声明

​    调用时使用格式是：

​      枚举类型名.枚举值

​      注：switch支持枚举类型，也支持String，int。如果是在switch语句中使用，在switch中需要加上枚举类型名，但是case中不能加枚举类型名，

​      例如：

​      enum Result{TRUE,FALSE}

​      某方法{

​      if(a == b)

​      return Result.TRUE;}

​      Result r = 某方法的返回值;

​      if(r == Result.TRUE)

​      System.out.println(xxx);

 **第九部分** **异常**

  **1.****什么是异常？异常机制有什么用？**

​    程序执行中发生了不正常的情况，这种不正常就是异常

​    提供异常机制可以将异常信息打印到控制台，程序员看到异常信息后可以对程序进行更改，对程序加强，提高程序健壮性

​    异常信息是有java虚拟机（JVM）打印出来的

  **2.java****中异常是以什么形式存在的呢？**

​    异常在java中以类的形式存在，每一个异常类都可以创建异常对象

​    比如 NullPointerException n = new NullPointerException("空指针异常");

​    实际上每当代码到出现异常时，JVM会自动new一个异常对象，并且JVM会把异常对象抛出，打印输出信息到控制台

  **3.****不同位置出现的相同的类型的异常，此时异常类是相同的，但是由于每次出现异常都会****new****对象，因此不同位置的异常对象时不同的**

  **4.java****的异常处理机制**

​    （1）异常的继承结构：UML图

​        什么是UML？有什么用？

​          UML是一种统一建模语言，一种图标式语言（画图的），不是只有在java中使用，只要是面向对象的编程语言都有UML

​          一般画UML图的都是软件架构师或者系统分析师这些人使用，即软件设计师使用UML

​          在UML图中可以描述类和类之间的关系，程序执行的流程，对象状态等信息

​        UML图中的画法规范

​          实线空心箭头是继承关系，箭头指向父类;虚线空心箭头是实现关系，箭头指向接口;实线箭头关联关系

​    （2）Throwable的子类有两个，是Error和Exception，程序只要如果发生了错误，程序一定会终止执行，退出JVM，错误是不能处理的。而异常还可以进行更改

​      Exception只有两种子类，是ExceptionSubClass（Exception的直接子类）和RuntimeException

​      所有的RuntimeException及其子类叫做运行时异常（未受检异常、非受控异常），ExceptionSubClass（Exception的直接子类）叫做编译时异常（受检异常、受控异常），所有异常都是在运行时发生

​      编译时异常是表示必须在编写程序时处理，否则会编译器报错，运行时异常在编写程序时既可以处理，也可以不处理

​      不论是错误还是异常，都是可抛出的

​    （3）所有异常都是在运行阶段发生的，编译时异常是因为不修改编译会报错才得名的

​    （4）编译时异常和运行时异常的区别

​        编译时异常一般发生的概率较高 因此对于发生概率较高的异常需要在运行之前对其进行预处理

​        运行时异常一般发生的概率较低 不需要在运行前进行预处理

​        倘若没有两者的划分，在编写程序时必需将所有的异常处理，会发生

​          程序绝对安全，但是程序员编写的代码太累，代码到处都是处理异常

​    （5）对异常处理的两种方式

​      第一种方式：在方法声明的位置上使用throws关键字，抛给上一级，谁调用，抛给谁

​        注意上报的异常必须是出现的异常或者该异常类的父类，同时也可以上报多个异常，用逗号隔开

​      第二种方式：使用try..catch 语句进行异常的捕捉，这个异常谁也不知道，因为已经捕捉了

​        异常抛到此处为止，不再往上抛了，一般不建议在main方法中上抛，这样会直接抛给JVM程序结束，因此一般main方法中的异常使用try...catch

​        语法：

​          try{

​              //try尝试的代码

​              }

​          catch(异常类名 变量名){

​            //catch抓到异常以后走的分支

​            //catch后面的异常类名既可以写确切的具体的异常类型，也可以是该异常类型的父类型

​          }

​          当想要出现不同的异常的时候进行不同的处理方式的时候可以用多个catch语句,建议catch的时候精确地一个一个地处理，这样有利于程序的调试

​          多个catch时从上到下的catch的异常应该是从小到大

​          try{语句

​              }catch(异常类名1 变量名1){

​                  catch执行语句

​              }catch(异常类名2 变量名2){

​                  catch执行语句

​              }catch()...

 

​      注意：java中如果出现了异常并且一直上抛，最终抛给了main方法，main方法继续上抛给了调用者JVM，当JVM得知异常以后，只有一种结果，那就是终止程序

​         只要异常没有被捕捉，采用了上报的方式，此方法的后续代码不会执行

​         另外当try语句块中某一行代码出现异常，该行后面的代码不会执行，而捕捉以后的代码仍然可以执行

​         当一个方法中的代码出现异常以后，如果开始上报，那么此方法就结束了

​         在JDK8以后有新特性，catch的后面的异常类名可以用或来连接了

​          例如： catch(NullPointException | ArithmeticException | FileNotFoundException e)是正确的

​    （6）两种处理方式的选择标准

​      如果希望调用者来处理，那么就使用throws上报的方式处理

​      其他情况使用try catch捕捉去处理

​    （7）异常对象的重要方法

​      获取异常简单的描述信息

​        String msg = exception.getMessage();//返回值是String类型

​        举例：

​            NullPointerException npe = new NullPointerException("空指针异常");//有参数构造方法

​            System.out.println(npe.getMessage());//输出“空指针异常”，此时获取的就是构造方法传进去的参数

​      打印异常追踪的堆栈信息

​        exception.printStackTrace();  //////这行代码要在catch里面写上，养成好习惯，否则出现异常也无法得知

​        举例：

​            NullPointerException npe = new NullPointerException("空指针异常");

​            npe.printStackTrace();//输出java.lang.NullPointerException: 空指针异常 at Exception02.main(Exception02.java:3)

​                        //后台有另外一个线程控制这个异常信息的输出,采用的是异步线程的方式打印的

​    （8）throw关键字是手动抛出异常的意思，异常都有一个标识符，用throw 标识符就可以把该异常手动抛出了

​    （9）怎么在实际的开发中看异常的追踪信息进行调试？

​      源代码：

​        public static void main(String[] args) {

​          try{m1();

​          }catch(FileNotFoundException ffe){

​            ffe.printStackTrace();

​          }

​        }

​        private static void m1() throws FileNotFoundException {

​          m2();

​        }

​        private static void m2() throws FileNotFoundException{

​          new FileInputStream("N");

​        }

 

异常信息：从上往下看，首先看异常信息，即第736行，737-740是SUN公司写的，不会出错，从741开始往下看，也即真正的出错应该是741行

​          java.io.FileNotFoundException: N (系统找不到指定的文件。)

​            at java.base/java.io.FileInputStream.open0(Native Method)

​            at java.base/java.io.FileInputStream.open(FileInputStream.java:213)

​            at java.base/java.io.FileInputStream.<init>(FileInputStream.java:155)

​            at java.base/java.io.FileInputStream.<init>(FileInputStream.java:110)

​             at Exception03.m2(Exception03.java:19)

​            at Exception03.m1(Exception03.java:15)

​            at Exception03.main(Exception03.java:7)

​            19行出问题导致15行出问题，15导致7，因此应先看19行的代码。它是根本的错误来源

​            异常追踪信息，从上往下一行一行看，，但是SUN公司写的不用看，主要的问题是出现在自己写的代码上

​              区分SUN的代码和自己的代码就是包名有差别

​    （10）关于try...catch中的finally子句

​        在finally子句中的代码是最后执行的，并且是一定会执行的，即使try中的代码出现了异常

​        finally语句必须使用在try..catch中，不能单独编写

​        finally往往都在语句块中完成资源的释放/关闭，因为finally中的代码比较有保障，因为即使try中的代码出现异常，finally中的代码也会正常执行

​          除了System.exit(0);退出虚拟机这条指令出现在try中以外，它是一定会执行的

​         当只有try和finally没有catch的时候一样可以通过，并且如果try里有return也组织不了finally语句的执行，先执行try再执行finally最后结束

​          try不可以单独使用，但是try和finally可以连用

​        代码执行顺序

​          try...

​          catch...

​          finally..

​          return;(return执行方法必定结束)

 

​          同时有时为了保证代码的顺序是从上而下的，会出现难以理解的结果

​          int i = 100;

​          try{

​            return i;

​          }

​          finally{

​            i++;

​          }

 

​          此时return的i是100，而不是101，但是finally确实是在return之前执行的，其实是将i赋给了j，而return的是j

​    （11）final、finally、finalize之间的区别

​        final是一个关键字，修饰的变量表示最终不变的

​        finally也是一个关键字，和try联合使用，使用在异常处理机制中，在finally中的代码一定会执行

​        finalize()是Object类中的一个方法，作为方法名出现，所以finalize是标识符

​          finalize()是JVM的GC垃圾回收器负责调用

​    （12）自定义异常类

​        sun提供的JDK中内置的异常肯定是不够用的，实际业务中有很多的业务需要有自己自定义的异常

​        怎么自定义异常类？(死记硬背即可)

​          第一步：编写一个类继承Exception（编译时异常）或者RuntimeException（运行时异常）

​          第二步：提供两个构造方法，一个是无参数的，一个是带有String参数的

​          举例：

​            public class MyException extends Exception{

​                public MyException() {

​                  //无参构造方法

​                }

 

​                public MyException(String message) {

​                  super(message);//有参构造方法

​                }

​             }

​        自定义异常什么时候用（接上面）

​          可以用

​          throw new MyException("自定义异常");

​          后在上一方法中

​          try{

​            原方法

​          }catch(MyException me)

​          {

​            me.getMessage();

​          }

​          来代替

​          System.out.println("自定义异常");

​          return;

​    （13）异常与方法覆盖

​        由于重写之后的方法不能比重写之前的方法抛出更多（宽泛）的异常，可以更少

​           也即儿子不能抛的比爹多，不能比爹抛的异常大

​          注：在运行时异常不再本规律内，因为编译器不考虑运行异常

​            开发中一般都是父类方法怎么写，子类方法就怎么写

​    （14）异常中的关键字

​        try     /*

​        catch      异常捕捉

​        finally   */

​        throws   在方法声明的位置上使用，表示上报异常信息给调用者

​        throw    手动抛出异常

​    （15）引用==null的这个判断条件当有短语或的时候尽量放到所有条件的最前面，同时最好写成null==引用，防止双等号写成单等号手误

 

**第十部分** **集合**

  **1.****什么是集合，有什么用？**

​    数组其实就是一个集合，集合是一个容器，可以容纳其他类型的数据，集合容量是无限的，可以自动扩容

​    集合是一个容器、载体，可以一次容纳多个对象，在实际开发中如果连接数据库，数据库中有10条记录，假设这10条记录查询出来，java程序会将这10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个又一个的数据展现出来

  **2.****集合不能直接存储基本数据类型，也不能直接存储****java****对象，****java****中存储的是****java****对象的内存地址（即引用）**

​    注：集合在java中本身就是个容器，是一个对象，也有自己的内存地址。集合任何时候存储的都是“引用”

  **3.****在****java****中每个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等价于将数据放到了不同的数据结构当中**

​      什么是数据结构？

​        数据存储的结构。不同的数据结构，数据存储的方式不同

​          比如：数组，二叉树，链表，哈希表、图等

​      放数据到不同的集合，就会使用了不同的数据结构存储数据

  **4.****集合都在****java.util.\*** **这个包下**

​    所有的集合类和集合接口都在这个包下

​    new ArrayList();    创建一个底层数组的集合

​    new LinkedList();    创建一个底层链表的集合

​    new TreeSet();     创建一个底层二叉树的集合

  **5.****在****java****中集合分为两大类**

​    一类是单个方式存储元素（即一个一个元素进行存储）  叫做Collection

​      单个方式存储元素的这类集合中的超级父接口:java.util.Collection

​    一类是以键值对的方式存储元素（即以键（key）和值（value）为一对来一对一对的存储，键和值存储的都是java对象的内存地址，其中值是键的附属品）  叫做Map

​      以键值对存储元素的这类集合中的超级父接口:java.util.Map

  **6.****集合的继承结构图****(<---****代表继承****,<--****代表关联****,<-****代表实现****)****，（泛化关系就是继承关系）**

   Collection继承图

​    Iterable[方法:iterator()](可迭代的，可遍历的，所有元素都可迭代遍历)<---Collection

​    Iterator[方法:hasNext()、next()、remove()]<--Collection

 

​    Collection调用父类Iterable中的iterator()方法可以生成一个Iterator对象（即迭代器对象），利用里面的三个方法可以实现对这个Collection的遍历（迭代）

 

​    Collection<---List(数据存储特点:有序（元素存和取的顺序相同，先进先出）、可重复（允许元素重复），元素有下标（从0开始以1递增，是有序的基础）)

​    Collection<---Set(数据存储特点:无序（存和取的顺序不一定相同）、不可重复、无下标)

​    Set<---SortedSet(数据存储特点:无序、不可重复、但是元素可以按照大小自动排序，叫做可排序集合)

 

​    以上都是接口,以下五个是类，需要new这五种类，接口不能new

​    List<-ArrayList (底层数组数据结构，非线程安全)

​    List<-LinkedList(底层双向链表数据结构)

​    List<-Vector  (底层数组数据结构，线程安全（所有方法都有synchronized关键字修饰），效率较低，使用较少)

 

​    Set<-HashSet[实际上在new的时候底层new了一个HashMap集合，向HashSet加数据实际上是加到了HashMap里了，HashMap是哈希表数据结构]

​    SortedSet<-TreeSet[实际上在new的时候底层new了一个TreeMap集合，向TreeSet加数据实际上是加到了TreeMap里了，TreeMap是二叉树数据结构]

 

   Map继承图（和Collection集合完全没关系）[所有Map集合的key都是无序（不一定挂到哪个单向链表中）不可重复（equals方法保证key不可重复，否则value覆盖）的，因此Map的key的特点和Set集合元素特点相同]

​    其实Collection中的TreeSet和HashSet其实就是TreeMap和HashMap的key部分

​    Map<-HashMap(线程不安全，底层是哈希表数据结构)

​    Map<-Hashtable(线程安全，底层是哈希表数据结构，所有方法都有synchronized关键字修饰，效率较低，使用较少，因为控制线程安全有其他更好的方案)

​    Map<---SortedMap(其key的特点是无序不可重复，而放到这里的key部分的元素会自动按照大小顺序排序，称为可排序集合)

 

​    Sorted<-TreeMap(底层二叉树，key数据可以自动按照大小排序)

​    Hashtable<---Properties(线程安全（因为继承Hashtable），底层哈希表，要求key和value都是String类型的)[被称为属性类]

 

​    Map集合的key，就是一个Set集合，在Set集合中放数据，其实就是放到了Map数据的key部分

  **7.java.util.Collection****接口中的常用方法**

​    （1）Collection中如果没有泛型的限制，那么可以存储Object的所有子类型，使用泛型以后，只能存储某个具体的类型，集合中不能存基本数据类型和java对象，只能存地址

​    （2）Boolean add (Object o)

​       向集合中添加元素

​      举例

​          Collection c = new ArrayList();

​          c.add(1200);    //自动装箱

​          c.add(true);

​          c.add(new Object());

​    （3）int Size()

​      获取集合中元素的个数

​       举例

​          System.out.println(c.size());    // 3

​    （4）void clear()

​      移除集合中的所有元素，清空集合

​      举例

​          c.clear();

​          System.out.println(c.size());    // 0

​    （5）Boolean contains(Object o)

​      判断某个对象是否在当前集合中，包含就返回true，反之返回false

​      调用的是equals方法进行的比对，equals方法返回true就代表包含该元素

​      举例

​          String a = new String("abc");

​          c.add(a);

​          String b = new String("abc");

​           System.out.println(c.contains(b)); // true,因为a.equals(b)为true

​      正因如此：

​      放在集合里的元素需要重写equals方法

​      放在集合里的元素需要重写equals方法

​      放在集合里的元素需要重写equals方法

 

​    （6）Boolean remove(Object o)

​      删除集合中的某个元素，删除成功返回true，失败返回false

​      举例

​          System.out.println(c.remove(120));   // false

​      同上面的理，这里remove同样调用了equals方法

​                String a = new String("abc");

​                c.add(a);

​                String b = new String("abc");

​                c.remove(b);

​                System.out.println(c.size());// 0

 

​      注：在迭代集合元素的过程中，不能调用集合对象的remove方法来删除元素，因为集合机构一旦改变，就必须要重新更新迭代器，否则会出现异常

​        需要用迭代器Iterator中的remove方法删除元素

​    （7）Boolean isEmpty()

​      判断集合中元素个数是否为0，如果为0返回true，非空返回false

​      举例

​          System.out.println(c.isEmpty());    // false

​    （8）Object[] toArray()[了解]

​      将集合转换为数组

​      举例

​          Object[] o = c.toArray();

​          for (int i = 0; i < c.size(); i++) {

​            System.out.println(o[i]);

​    （9）注：以下的遍历/迭代方式适用于所有Collection通用的方式，但是在Map中不能用

​      Iterator iterator()

​       Iterator对象（负责迭代集合）中有以下方法，用于迭代集合

​      注：迭代器最初并没有指向集合的第一个元素

​        （1）Boolean hasNext()

​          如果仍然有元素可以迭代就返回true，无元素可以迭代就返回false

​        （2）Object next()

​          返回迭代的下一个元素，即让迭代器前进以为并将指向的元素返回（拿到）

​           不管你之前存进去的数据是什么类型，取出来的统一是Object,还是原来的类型，但是输出的时候是String，因为调用了toString方法

​        （3）void remove()

​          删除迭代器当前指向的集合中的元素

​          想要在迭代集合时删除里面的元素应该使用迭代器的remove方法，不要用Collection中的remove方法

​      举例

​          Collection c = new ArrayList();

​          c.add("abc");

​          c.add("def");

​          c.add(100);

​          c.add(new Object());

​      //    首先获取集合的迭代器

​          Iterator it = c.iterator();

​      //    通过获取的迭代器对象it中的方法开始迭代/遍历集合

​          while (it.hasNext()){

​            System.out.println(it.next());

​            //   abc

​            //   def

​            //   100

​            //   java.lang.Object@723279cf

 

​      集合结构只要发生改变，迭代器必须重新获取

​      当集合结构发生改变而未重新获取迭代器时，调用next()方法时会出现java.util.ConcurrentModificationException异常

  **8.List****接口中常用方法** **[list****接口特点（元素有下标，从****0****开始，以****1****递增，有序可重复）****]**

​    （1）List接口不仅继承了Collection中所有的方法，还有自己独有的方法，只列出List特有的方法

​    （2）void add(int index,E element)

​      在列表的指定位置插入指定元素，第一个数是下标

​      使用不多，因为底层是数组，这样的效率不高

​    （3）E get(int index)

​      通过下标来取元素

​      从而引出List集合特有的遍历方式，set没有

​           for (int i = 0; i < l.size(); i++) {

​            System.out.println(l.get(i));}

​    （4）int indexOf(Object o)

​      获取指定对象第一次出现的索引(下标)

​    （5）int lastIndexOf(Object o)

​      获取指定对象最后一次出现的索引（下标）

​    （6）E remove(int index)

​      删除指定下标的对象元素

​    （7）E set(int index,E element)

​      将指定下标的元素修改

​     注:E指的是泛型，可以将其当做Object

  **9.ArrayList****（用的最多的集合）更使用于查找的业务**

​    （1）ArrayList初始话容量是10（底层先创建了长度为0的数组，当添加第一个元素的时候会初始化容量为10），底层是Object类型的数组

​    （2）ArrayList的构造方法有有参的和无参的，如果无参，那么默认容量为10，如果有参数，那么其容量就是你构造方法中的参数

​      其有参数的构造方法也可以把一个集合传进去，这样就可以把一个例如Set类型的集合转换成ArrayList集合

​      size()方法是获取集合中元素的个数，而不是集合的容量

​    （3）ArrayList的扩容：

​      扩容后增长到原容量的1.5倍，需要尽可能少的扩容来提高效率，因此需要尽可能的预估计数组大小来给定初始容量减少扩容次数

​    （4）二进制位运算

​      i >> x 代表二进制数i右移了x位，会除以2^x

​      i << x 代表二进制数i左移了x位，会乘以2^x

 

  **10.LinkedList****与单向链表数据结构（从后节点找不到前节点）**

​    LinkedList集合没有初始化容量，链表的增删效率高，检索效率低，内存地址不连续

​    **单向链表**

​      链表中最基本的单元是节点（Node），对于单向链表而言，每个节点（Node）中都有两个属性，第一是存储的数据，第二是下一个节点的内存地址

​      头节点是最前面的节点（headerNode），末尾节点是最后面的节点（lastNode）,末尾节点的指针为空

​    **双向链表**

​      每个节点由三个部分构成：数据、下个节点的内存地址、上个节点的内存地址

​      其中会存在first和last节点，去指向第一个和最后一个元素，在最初双向链表中没有任何元素，first和last引用都是null

​      链表的优点：随机增删效率较高（因为增删元素不涉及到大量元素的位移）

​      链表的缺点：查询效率较低（每一次查找某个元素都需要从头节点开始往下遍历），LinkedList链表同样有下标，但是是否有下标并不是查找快的标准

​    **综上：**ArrayList把检索发挥到极致，非线程安全的集合

​       LinkedList双向链表，把随机增删发挥到极致

​       由于加元素大部分都是从末尾加，因此ArrayList用的比LinkedList多

​       不管是LinkedList还是ArrayList都不需要关心是哪个集合，因为我们是面向接口编程，调用的方法都是接口中的方法

  **11.Vector****集合**

​    （1）底层也是一个数组，初始化容量是10，满了之后扩容，扩容后是原容量的二倍：10->20->40->80

​      (ArrayList扩容是原容量1.5倍，10->15->22)

​    （2）Vector中的所有方法都有synchronized关键字，都是线程同步的，因此线程安全，但是效率较低，用的较少

​    （3）怎么将一个线程不安全的ArrayList集合转换成线程安全的呢

​      使用集合工具类：java.util.Collections中的synchronizedList() 方法

​        注意：java.util.Collection是集合接口，java.util.Collections是集合工具类

​        举例：

​            List l = new ArrayList();

​            Collections.synchronizedList(l);

  **12.****泛型**

​    （1）泛型是JDK5.0以后推出的新特性

​    （2）使用泛型List<Animal>之后，表示这个List集合中只允许存储Animal类型的数据

​      举例：List<Animal> l = new ArrayList<Animal>();

​      其中可以用Cat、Bird等类去继承Animal即可，这样使用泛型以后，集合中的元素的数据类型更加统一了

​    （3）某个方法是否支持泛型可以查看源代码中是否有<E>，如果有就是支持泛型

​    （4）使用泛型之后，每一次迭代器返回的数据类型都是Animal类型，这里不需要再向下用instanceOf进行转型了

​    （5）泛型这种语法机制只是在程序的编译阶段起作用，只是给编译器参考的（运行阶段泛型没用）

​    （6）泛型的好处

​      1.集合中的存储的元素类型统一了

​      2.从集合中取出的元素的类型是泛型指定的类型，不需要进行大量的向下转型

​      泛型的坏处

​       导致集合中存储的元素缺乏多样性

​    （7）JDK8之后推出了自动类型推断机制（钻石表达式）

​      即在JDK8以前，List<Animal> l = new ArrayList<Animal>()中的ArrayList<Animal>中的Animal必须要写，

​        但是在JDK8以后，可以不写后面的Animal了，因为JDK8有自动推断机制

​    （8）自定义泛型

​        自定义泛型时，<>里面的是一个标识符，可以随便写

​        如果写了泛型却不用，就是Object类型

​        E是element首字母，T是type首字母

​      举例：

​      class MyClass<随意写的标识符（一般写T或者E）>{

​        public 随意写的标识符（一般写T或者E） doSome(){

​          return null;

​        }

​      }

 

​      public class JiHe07{

​        public static void main(String[] args) {

​          MyClass<String> mc = new MyClass<>();      //这里的<>的String可以换成任意一种数据类型

​          mc.doSome();                   //此时的doSome默认返回String

​        }

​      }

  **13.forEach**

​    （1）JDK5以后推出新特性，叫做增强for循环（forEach）

​    （2）语法格式：

​        for(元素类型 变量名 : 数组或集合){}

​        举例：

​            int[] arr = {20,234,325,2,67};

​            for(int i : arr){        //i代表数组中每一个元素

​              System.out.println(i);}

​    （3）增强for的缺点：

​        没有下标，在需要使用下标的循环中不建议用增强for

​    （4）其中for里的元素类型可以和泛型结合起来，如果没有使用泛型，那么就可以写Object

​    （5）List集合遍历方式有三：1.下标遍历 2.迭代器遍历 3.foreach遍历

  **14.Set****集合特点**

​    （1）HashSet集合特点

​        无序不可重复，即使加入了相同的数据，在输出遍历的时候也只会输出一次

​        存储时和取出时的顺序不同

​        放到HashSet中的数据实际上是放到了HashMap集合的key部分了

​    （2）TreeSet集合特点

​         无序不可重复，但是存储的元素输出时可以自动按照大小顺序排序，被称为可排序集合

  **15.java.util.Map****接口中常用的方法**

​    （1）Map和Collection之间没有继承关系，key和value都是引用数据类型，都存储对象的内存地址，key起到主导地位，value是key的附属品

​    (2)void clear()

​      清空Map集合

​    (3)boolean containsKey(Object key)

​       判断某个Map中是否包含某个key

​      举例：

​        System.out.println(m.containsKey(3));      //true

​    (4)boolean containsValue(Object value)

​      判断某个Map中是否包含某个Value

​      举例：

​        System.out.println(m.containsValue("水原千鹤"));      //true

​    注：contains方法底层都是调用equals方法，所以自定义的类型需要重写equals方法

​    (5)V get(Object key)

​      通过key来获取value

​      举例：

​          System.out.println(m.get(1));      //水原千鹤

​    (6)boolean isEmpty()

​       判断Map集合是否为空

​    (7)Set<K> keySet()

​      获取Map集合所有的key，返回一个Set集合，可见Set集合其实是Map集合的key部分

​    (8)V put(K key, V value)

​      向Map集合中添加键值对

​      举例：

​            Map<Integer,String> m = new HashMap<>();

​             m.put(1,"水原千鹤");

​            m.put(2,"七海麻美");

​            m.put(3,"更科琉夏");

​            m.put(4,"樱泽墨");

​    (9)V remove(Object key)

​      通过key删除键值对

​      举例：

​            m.remove(4);

​            System.out.println(m.size());      //3

​    (10)int size()

​      获取Map中键值对的个数

​      举例：

​            System.out.println(m.size());      //4

​    (11)Collection<V> values()

​      获取Map中所有的Value返回一个Collection

​      举例：

​            Collection<String> c = m.values();   //水原千鹤

​            for (String s:c){             七海麻美

​              System.out.println(s);        更科琉夏

​             }

​    (12)Set<Map.Entry<K,V>> entrySet()

​      将Map集合转换成Set集合

​        假设有一个Map集合

​          key     value

​           1     水原千鹤

​           2     更科琉夏

​           3     七海麻美

​           4     樱泽墨

​        Set set = map.entrySet();

​        Set集合对象是这样：

​          1=水原千鹤

​          2=更科琉夏

​          3=七海麻美

​          4=樱泽墨

​        转换后一共四个元素，其中的数据类型是 Map.Entry<K,V>

  **16.Map****集合的遍历方法**

​        Map<Integer,String> m = new HashMap<>();

​        m.put(1,"水原千鹤");

​        m.put(2,"七海麻美");

​        m.put(3,"更科琉夏");

​        m.put(4,"樱泽墨");

 

​    （1）获得所有的key，通过遍历所有的key来遍历value

​         Set<Integer> s = m.keySet();

​         //获取所有的key来用foreach遍历后获得value

​         for(Integer i : s){

​           System.out.println(key + "=" + m.get(i));

​    （2）使用Set<Map.Entry<K,V>> entrySet()方法

​        这个方法可以将Map集合转换成Set集合，Set集合中的元素类型是Map.Entry

​          Set<Map.Entry<Integer,String>> s = m.entrySet();

​          //遍历Set集合,每次取出一个Node

​          for(Map.Entry<Integer,String> me : s){

​            System.out.println(me.getKey() + "=" + me.getValue());

​          }

​    注：一般使用第二种，因为第二种的效率较高，因为获取key和value都是从node对象中获得的属性值，适合于大数据量

  **17.HashMap****集合（底层是哈希表数据结构）**

​    （1）哈希表（散列表）数据结构

​      1.哈希表是一个数组和单向链表的结合体

​        数组：在查询上效率高，随机增删效率低

​        单向链表：和数组相反

​        哈希表将上面的两种数据结构融合在一起，充分发挥他们的各自优点

​          也即有一个数组Node[] nodes，这个数组的元素都是一个单向链表，这个Node有哈希值

​            （是key的hashCode()方法的执行结果，哈希值通过哈希函数/算法可以转化成数组下标）、key、value和下一个Node的内存地址)

​      2.map.put(k,v)的实现原理，即哈希表插入元素的原理

​        第一步：先将k，v封装到Node对象当中

​        第二步：调用key的hashCode()方法得出哈希值，然后通过哈希函数/哈希算法将hash值转换成数组下标，下标位置上如果没有任何元素，就把Node添加到该位置

​            如果下标对应的位置上有链表，此时会拿着k和链表每一个节点中的k进行equals;如果所有的equals返回都是false

​            那么这个新节点将会被添加到链表的末尾;如果其中有一个equals返回了true，那么会拿新的v覆盖掉旧的v

​      3.map.get(k)的实现原理，即哈希表获取元素的原理

​            先调用k的hashCode()方法得出哈希值，通过哈希算法转换成数组下标，通过下标定位到某个位置上。如果这个位置什么也没有，就返回null;

​            如果这个位置上有单向链表，那么会拿着参数k和单向链表上的每个节点中的k进行equals。如果所有的equals方法都返回null，那么get方法返回null

​            只要其中有一个参数k和k equals的时候，就返回这个节点的value

​      4.如果o1和o2的hash值相同，一定会在同一个单向链表上，如果两者的hash值不同，有可能会因为执行哈希算法后数组下标相同，仍然在同一个链表上，叫做“哈希碰撞”

 

​      注：HashMap集合的key会先后调用两个方法，分别是hashCode()以及equals()，因此hashMap的key部分和hashSet的这两个方法都需要重写

​        同一个单向链表上，所有节点的hash值相同，因为他们的数组下标相同，但同一个链表上k和k的equals方法肯定返回false，都不相等

​        倘若将所有的hashCode()返回的值为固定值，那么会导致底层哈希表变成了纯单向链表，这种情况叫做散列分布不均匀,但是也不能所有的单向链表返回都不一样，这样就变成纯一维数组，也是散列分布不均匀，因此重写HashCode有一定的技巧

 

​      **4.****为什么哈希表增删和查询的效率都高？**

​        因为增删是在链表上进行的，查询也不需要都扫描，只需要部分扫描

​    （2）HashMap集合的默认初始化容量是16，默认加载因子是0.75

​        默认加载因子是指当集合的底层数组容量达到75%时就开始数组扩容了，扩容是扩容后是原容量的2倍

​       HashMap的初始化容量必须是2的次幂，这也是官方推荐的，因为这是达到散列均匀提高HashMap的存取效率所必须

​    （3）如果一个类的equals方法重写了，那么hashCode方法必须重写，并且如果equals方法返回true，那么hashCode返回值必须一样

​    （4）hashCode方法和equals方法不用研究了，直接用idea直接生成即可，但是这两个方法需要同时生成

​    （5）在JDK8以后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数小于6时，会重新把红黑树变成单向链表

​        是为了提高检索效率，二叉树会进一步减少搜查范围，提高效率

​    （6）hashMap的key部分允许为null，但是只允许出现一个null，因为如果key重复会覆盖value，同时也可以通过null这个key来获取value，面试可能问，开发用不着

​      但是HashTable的key部分不允许为null，会出现空指针异常，因为上来就会调用key的hashCode方法，key为空时直接空指针异常，而value为空也是空指针异常

​        因此HashTable的key和value都不能为空，而HashMap的key和value都可以为空

  **18.HashTable****集合**

​    （1）HashTable底层同样是哈希表数据结构

​    （2）HashTable初始化容量为11，默认加载因子是0.75

​    （3）HashTable的扩容：新容量是老容量2倍加1

  **19.properties****集合的相关方法****(****线程安全****)**

​    （1）properties是一个Map集合，继承Hashtable，其key和value都是String类型，Properties被称为属性类对象

​    （2）Object setProperty(String key，String value)

​      存数据，调用了Hashtable的put方法

​    （3）String getProperty(String key)

​      通过键来取值

​    举例:

​        Properties p = new Properties();

​        p.setProperty("1","水原千鹤");

​        System.out.println(p.getProperty("1"));     //水原千鹤

  **20.TreeSet****集合**

​    （1）TreeSet底层实际上是TreeMap，TreeMap底层是一个二叉树

​    （2）放在TreeSet中的数据实际上是方法了TreeMap的key部分了

​    （3）TreeSet中的元素：无序不可重复，但是可以按照元素的大小(字典顺序)顺序自动排序：称为可排序集合

​    （4）TreeSet是无法对自定义类型排序的，因为自定义类型并没有实现java.lang.Comparable接口，会出现ClassCastException异常

​        因此放在TreeSet集合中的元素需要实现java.lang.Comparable接口并实现compareTo方法，equals可以不重写

​    （5）CompareTo方法的返回值很重要：

​        返回0表示相同，value会覆盖

​         返回>0，会继续在右子树上找

​        返回<0，会继续在左子树上找

​    （6）自平衡二叉树

​      1.遵循左小右大的原则进行存放，所以存放时需要进行比较

​      2.遍历二叉树有三种方式

​        前序遍历：根左右

​        中序遍历：左根右

​        后序遍历：左友根

​        注：前中后说的是“根”的位置

​      3.TreeSet或者TreeMap中的迭代器采用的是中序遍历方式：左根右

​      4.按照左小右大的顺序并且按照左根右的遍历方式出来的数据已经是从小到大自动排序的了

​    （7）TreeSet中元素可排序的第二种方式：使用比较器的方式

​      单独写一个比较器实现java.util.Comparator接口（Comparable是java.lang包下的,Comparator是java.util包下的）

​          class 比较器 implements Comparator<>{

​            public int compare(参数1 , 参数2){

​              指定比较规则

​            }

​          }

​          //new集合时需要加上有比较器的构造方法

​          TreeSet<> t = new TreeSet<>(构造器);

​      注：使用匿名内部类也可以

​      总结：放到TreeSet或者TreeMap中的元素实现排序可以有两种方式

​        1.放在集合中的元素实现java.lang.Comparable接口

​        2.在构造集合时给其传一个比较器对象comparator，其构造符合OCP原则

​        注：如果比较规则只有一个或者不会发生改变的时候，建议使用1

​          如果比较规则有多个，且需要多个比较规则之间频繁切换时，建议使用2，

  **21.Collections****集合工具类**

​    （1）Collections.synchronized(Arraylist al)

​      可以将线程不安全的ArrayList转换成线程安全的

​    （2）Collections.sort(List)

​      或者Collections.sort(list集合，比较器)

​      可以将List集合进行排序，前提是List里的元素可以排序（实现了Comparable接口）

​    （3）List<> l = new ArrayList<>(Set)

​      将Set集合转换成List集合

 

**第十一部分** **IO****流****[Input and Output]**

  **1.****流其实是文件的输入和输出****[****参照物都是内存和硬盘****]****，通过****IO****可以完成文件的读和写**

​    将文件添加到内存中叫做输入（流）[Input（InputStream）]，过程被称作读[Read]

​    将文件从内存添加到硬盘叫做输出（流）[Output(OutputStream)]，过程被称作写[Write]

  **2.IO****的分类**

​    （1）按照流的方向进行分类

​        以内存为参照物

​        往内存中去，叫做输入或者读

​        从内存中出，叫做输出或者写

​    （2）按照读取数据方式进行分类

​       字节流文件：

​        有的流按照字节的方式读取数据，一次读取1个字节byte，即一次读取8个二进制位

​          这种流是万能的，什么类型的文件都可以读取，包括：文本文件、图片、声音文件、视频等

​          会出现读取到一个中文字符的一半的情况

​       字符流文件：

​        有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的

​          这种流不能读取图片、声音文件、视频等，只能读取文本文件，连word文件也无法读取

​    （3）java中所有的流都在java.io.*下

​       java中主要还是研究怎么new对象，调用流对象的哪个方法是读、哪个是写

​    （4）javaIO流下有四大家族

​        1.java.io.InputStream    字节输入流

​        2.java.io.OutputStream   字节输出流

​        3.java.io.Reader      字符输入流

​         4.java.io.Writer      字符输出流

​        注：在java中只要“类名”是以Stream结尾的都是字节流，以Reader/Writer结尾的都是字符流

​          四大家族的首领都是抽象类（abstract class）

​          所有的流都实现了java.io.Closeable接口，都是可以关闭的，都有close()方法

​            流毕竟是一个内存和硬盘之间的通道，用完后一定要关闭，否则会占用/耗费很多资源

​            因此要养成用完流要关闭的习惯

​    （5）所有的输出流都是可刷新的，都实现了java.io.Flushable接口,都有flush()方法

​      需要养成输出流在最终输出之后一定记得flush()刷新一下；这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道）

​        刷新的作用就是清空管道，如果没有flush，可能会导致数据丢失

​    （6）java.io包下需要掌握的流

​        文件专属：

​          java.io.FileInputStream

​          java.io.FileOutputStream

​          java.io.FileReader

​          java.io.FileWriter

​        缓冲流专属：

​           java.io.BufferedInputStream

​          java.io.BufferedOutputStream

​          java.io.BufferedReader

​          java.io.BufferedWriter

​        数据流专属：

​          java.io.DataInputStream

​          java.io.DataOutputStream

​        对象专属流：

​          java.io.ObjectInputStream

​          java.io.ObjectOutputStream

​        标准输出流：

​          java.io.PrintWriter

​          java.io.PrintStream

​        转换流（将字节流转换成字符流）：

​          java.io.InputStreamReader

​          java.io.OutputStreamWriter

​          一共16个流

  3.文件字节输入流 java.io.FileInputStream

​    （1）这是万能的流，任何类型的文件都可以用这个流来读

​    （2）字节的方式，完成输入的操作，完成读的操作（硬盘-->内存）

​    （3）路径在输入时需要是String或者是File 类型的数据，同时绝对路径中的//和\都可以，需要注意FileInputStream会抛出异常，需要使用try catch

​        路径同样可以使用相对路径，只是此时需要将文件放在IDEA的当前路径下：

​          工程project的根就是IDEA的默认当前路径，从工程project的根作为起点往下找，依旧可以使用/来写路径

​    举例：流的创建与关闭

​           FileInputStream fis = null;

​          try {

​            fis = new FileInputStream("C:\\Users\\fengchuiyusan\\Desktop\\练习.txt");   //创建流

​          } catch (FileNotFoundException e) {

​            e.printStackTrace();

​          }finally {

​            if (fis != null) {

​              try {

​                fis.close();        //关闭流

​              } catch (IOException e) {

​                e.printStackTrace();

​              }

​            }

​          }

​    （4）public int read();

​      从输入流中读取一个数据字节，如果已经到达文档末尾，返回-1

​      read一开始是在文件的顶头，不指向任何东西，每调用一次，指针就往后移一位

​      举例：

​         int data = fis.read();   //返回读取到的字节本身

​      可以利用循环读取文件中所有的字节

​      举例：

​            while(true){

​              int data = fis.read();

​              System.out.println(data);

​               if(data == -1){

​                break;

​              }

​         改造以后：

​               int data = 0;

​               while( (data = fis.read()) != -1){

​                  System.out.println(data);

​                 }

​      缺点：一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上时间/资源都耗费到交互上面了

​    （5）int read(byte[] b)

​      这个方法和前面一样，只是在加了一个byte数组，这样一次最多可以读取b.length个字节，减少硬盘和内存的交互，提高效率

​      注：这个方法返回的int是读到的字节数量，不是字节本身，可能等于数组容量，也可能小于数组容量，如果一个数据也没有读到，就会返回-1

​      在获得数组以后，String的构造方法中如果传入一个byte数组，可以将数组元素转为字符串，从而实现字符串的拼接显示

​        byte[] b = new byte[4];

​        int readCount = fis.read(b);//读取数据放到数组

​        System.out.println(new String(b));//将字节数组全部转成字符串

​        //而我们应该读了多少数据转多少数据的字符串，因此应该调用下面的构造方法

​        System.out.println(new String(b,0,readCount));

​    （6）需要掌握的最终版

​        这样写的代码可以完全读取了文件中的所有内容

​       import java.io.FileInputStream;

​        import java.io.FileNotFoundException;

​       import java.io.IOException;

 

​       public class IO04 {

​         public static void main(String[] args) {

​           FileInputStream fis = null;

​           try {

​             fis = new FileInputStream("C:\\Users\\fengchuiyusan\\Desktop\\abc.txt");

​             byte[] b = new byte[3];       //准备一个byte数组

​             while(true) {            //循环以保证完全读取

​               int readCount = fis.read(b);  //获得读取数据个数

​               if(readCount == -1) {

​                 break;           //已经读取文件结束

​               }

​               System.out.print(new String(b, 0, b.length));    //读取几个数据转几个，不自动换行

​             }

​            } catch (FileNotFoundException e) {

​             e.printStackTrace();

​           } catch (IOException e) {

​             e.printStackTrace();

​           } finally {

​             if (fis != null) {

​               try {

​                 fis.close();

​               } catch (IOException e) {

​                 e.printStackTrace();

​               }}}}}

​    （7）int available()

​      返回流中剩余的没有读到的字节数量

​       一上来直接用fis.available()就可以得到总字节数量，这样就可以直接new数组时new一个byte[] b = new byte[fis.available()];\

​        这样就不用循环了，读一次就可以了，使用String的只有一个byte数组参数的构造方法即可

​        但是这种方式不适合大文件，因为byte数组不能太大

​    （8）long skip(long n)

​      跳过n个字节不读

  **4.****文件字节输出流** **java.io.FileOutputStream**

​    （1）负责写，从内存到硬盘

​    （2）写完以后一定记得用flush刷新

​    （3）void write(byte[] b)

​      将b.length个字节从指定byte数组写入此文件输入流中

​      举例：

​               fos = new FileOutputStream("Test");//如果文件不存在会自动新建

​              byte[] b = new byte[] {97,98,99,100};

​              fos.write(b);

​              fos.flush();

 

​    （4）void write(byte[] b,int startIndex,int length)

​      将数组的指定位置指定长度的字节写入文件

​    注：以上方法谨慎使用，因为这是将文件清空以后重新写入

​    （5）可以以追加的方式进行写入，这样是在文件的末尾写入，不会清空原文件内容

​      方式是在构造方法中加入true

​      举例：

​        fos = new FileOutputStream("Test",true);

​    （6）将字符串写入一个文件中

​          FileOutputStream fos = null;

​          try {

​            fos = new FileOutputStream("Test",true);    //末尾添加

​            String s = "水原千鹤";

​            byte[] b = s.getBytes();             //字符串转数组

​            fos.write(b);

​            fos.flush();                  //记得刷新

​          } catch (FileNotFoundException e) {

​            e.printStackTrace();

​          } catch (IOException e) {

​            e.printStackTrace();

​          } finally {

​            if(fos != null){

​              try {

​                fos.close();

​              } catch (IOException e) {

​                e.printStackTrace();

​              }

​            }

​          }

​        }

​    （7）文件的复制

​      使用FileInputStream和FileOutputStream完成文件的拷贝，拷贝的过程应该是一边读，一边写

​        使用以上的字节流拷贝文件时，文件类型是万能的，什么类型都可以拷贝

 

​      public static void main(String[] args) {

​          FileInputStream fis =null;

​           FileOutputStream fos = null;

​          try {

​            fis = new FileInputStream("C:\\Users\\fengchuiyusan\\Desktop\\练习.txt");

​            fos = new FileOutputStream("C:\\Users\\fengchuiyusan\\Desktop\\练习2.txt",true);

​            byte[] b = new byte[1024*1024];       //每次1M去传输

​            int readCount = 0;

​            while((readCount = fis.read(b)) != -1){

​              fos.write(b,0,readCount);      //读多少写多少

​            }

​            fos.flush();

​          } catch (FileNotFoundException e) {

​            e.printStackTrace();

​          } catch (IOException e) {

​            e.printStackTrace();

​          } finally {       //分开try，如果一起try的话如果有一个出现了异常可能影响另一个流的关闭

​            if(fis != null ){

​              try {

​                fis.close();

​              } catch (IOException e) {

​                e.printStackTrace();

​              }

​            }

​            if(fos != null){

​              try {

​                fos.close();

​              } catch (IOException e) {

​                 e.printStackTrace();

​              }}}}

  **5.java.io.FileReader****与****java.io.FileWriter**

​    （1）文件字符输入流，只能读取普通文本，读取文本内容时比较方便快捷，一次读取一个字符

​      其框架和文件字节输入流一致，只是这里的byte数组变成了char数组

​      char[] chars = new char[4];

​      int readCount = 0;

​      while((readCount = reader.read(chars)) != -1){

​        System.out.print(new String(chars,0,readCount));  //读多少写多少

​      }

​    （2）文件字符输出流，只能输出普通文本

​      注意要有flush()刷新

​      其中的write()中的参数可以有char数组，也可以是char数组的一部分（几开始长多少），也可以是一个String的字符串

​      想要换行可以write("\n");

​    （3）使用这两个去拷贝文件时只能拷贝普通文本文件，能用记事本编辑的都是普通文本文件，和后缀无关

  **6.java.io.BufferedReader****和****java.io.BufferedWriter**

​    （1）这些字符流流中不需要我们自己写byte或者char数组，他们自带缓冲

​    （2）定义：如果一个流的构造方法中需要一个流的时候，被传进的流被叫做节点流，外部的流叫做包装流（处理流）

​        BufferedReader的构造方法就需要一个read流，因此构造方法可以这样写

​            FileReader fr = new FileReader("C:\\Users\\fengchuiyusan\\Desktop\\练习.txt");//节点流

​            BufferedReader br = new BufferedReader(fr);//包装流

​            br.close();//关闭流的时候只需要关闭包装流，不需要关闭节点流，因为实际上源代码会把节点流自动关闭

​    （3）String readLine();

​      可以读取文本的一整行

​          String s = null;

​          while((s = br.readLine()) != null){

​            System.out.println(s);//读取的时候是没有换行符的,所以需要println

​          }

​          br.close();

​    （4）这个不见得有多快，但是会比较方便

  **7.java.io.InputStreamReader****和****java.io.OutputStreamWriter**

​    （1）这是可以将字节流转换字符流

​          FileInputStream fis = new FileInputStream("");//字节流

​          InputStreamReader read = new InputStreamReader(fis);//由字节流转换成字符流

​          BufferedReader bufferedReader = new BufferedReader(read);//将字符流作为节点流进行包装

​      当然上面三行代码可以合并

​        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream));

​    （2）输出和输入两者是同理的，使用方法一致

  **8.java.io.DataInputStream****和****java.io.DataOutputStream****（了解）**

​    （1）java.io.DataOutputStream数据专属的流

​        这个流可以将数据连同数据的类型一并写入文件

​        注：这个文件不是普通文本文档，用记事本打不开

 

​          DataOutputStream dos = new DataOutputStream(new FileOutputStream("C:"));

​          //创建数据专属的字节输出流

​          dos.flush();

​          //记得刷新

​          dos.close();

​          byte b =100;

​          dos.writeByte(b);

​          //会把byte b中的byte类型和100都写进文件中

 

​          有

​           writeByte();

​           writeInt();

​           writeBoolean();

​           writeLong();

​           writeDouble();

​           等一系列方法

​    （2）java.io.DataInputStream

​        上面写入的数据生成的文件中的数据只能用这个流来读取，相当于一种加密机制，并且读取的时候你需要提前知道写入的顺序

​          并且读的顺序和写的顺序需要保持一致，才能正常取出数据

​          构造方法和上面的相反

​          有readByte();

​          readInt();

​          readBoolean()

​          readLong();

​          等一系列方法

  **9.java.io.PrintStream** **标准输出流（默认输出到控制台）**

​    （1）标准输出流不需要手动close

​    （2）可以修改输出方向（比如修改到log文件）

​      PrintStream ps = new PrintStream(new FileOutputStream("log"));

​      System.setOut(ps);

​      //此时在下面再用System.out.println输出时都会输出到log文件中

  **10.java.io.File** **类**

​    （1）File和四大流家族无关，它是一个类，不是一个流，所以它不能完成文件的读和写

​      File其实是文件和目录路径名的抽象表示形式

​        C:\Intel            是File

​        C:\Intel\Logs\IntelCPHS.log   是File

​      一个File对象既可能是路径，也可能是文件

​    （2）File类中常用方法

​        File f = new File("C:\\Users\\fengchuiyusan\\Desktop\\练习.txt");

 

​        boolean exist();

​        判断某个文件是否存在

​        f.exist();   //true

 

​        boolean createNewFile();

​        如果找不到这个文件，就以文件的形式创建出这个File对象，创建成功后返回true

​        System.out.println(f.createNewFile());   //true

 

​        boolean mkdir();

​        如果找不到这个文件，就以目录的形式创建出这个File对象，创建成功后返回true

​        System.out.println(f.mkdir());   //true

 

​        boolean mkdirs();

​        如果找不到这个文件，就以多重目录的形式创建出这个File对象，创建成功后返回true

​        System.out.println(f.mkdirs());   //true

 

​        String/File getParent()/getParentFile();

​        获取文件的父路径

​        System.out.println(f.getParent());   //C:\Users\fengchuiyusan\Desktop

 

​        String getAbsolutePath()

​        获取File对象的绝对路径

​        System.out.println(f.getAbsolutePath());    //C:\Users\fengchuiyusan\Desktop\练习.txt

 

​        String getName();

​        返回由此抽象路径表示的文件或者目录的名称

​        System.out.println(f.getName());    //练习.txt

 

​        boolean isDirectory();

​        判断是否是一个目录

 

​        boolean isFile();

​        判断是否是一个文件

 

​        long lastModified();

​        获取文件最后一次修改时间

​        System.out.println(f.lastModified());      //1596773215234

 

​        long length();

​        获取文件的大小

​        System.out.println(f.length());         //153（字节）

 

​        File[] listFiles();

​        获取当前目录下所有的子文件

​        File f = new File("C:\\Program Files");

​        File[] fs = f.listFiles();

​        for(File fs2 : fs){

​          System.out.println(fs2.getAbsolutePath());

​        }

​        //可以获得所有的绝对路径

  **12.java.io.ObjectInputStream****（反序列化）和****java.io.ObjectOutputStream****（序列化）**

​    （1）对象的序列化和反序列化

​      序列化,Serialize：将java对象传到硬盘文件中,将java对象的状态保存下来[拆分对象]（在网络传输是需要将java对象切成一块一块的，并把每一块都编上号）

​      反序列化,DeSerialize：将java对象从硬盘文件恢复到内存中[组装对象]

​    （2）参与序列化和反序列化的对象需要实现Serializable接口

​      否则会出现java.io.NotSerializableException异常、

​    （3）源代码发现Serializable接口只是一个标志接口，接口中什么代码都没有，起到了标识的作用

​        java虚拟机看到这个类实现了这个接口以后，可能会对这个类进行特殊待遇

​       接口有两种，一种是普通的，一种是标志接口

​       标志接口是用来给JVM看的，一旦JVM看到后，会为该类自动生成一个序列化版本号

​    （4）举例：

​    //序列化

​       Student s = new Student();

​      ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("xxx"));

​      oos.writeObject(s);

​      oos.flush();

​      oos.close();

​    //反序列化

​      ObjectInputStream ois = new ObjectInputStream(new FileInputStream("sss"));

​      Object obj = ois.readObject();

​      ois.close();

​    （5）怎么一次序列化多个对象

​      将对象放到集合中，序列化集合

​      oos.writeObject(userList);//集合中放了许多其他对象，注意其中包括的对象要继承序列接口

​    （6）如果不想要某个对象中的属性参与序列化，可以在该属性前加一个关键字

​        transient 游离的

 **第十二部分** **多线程**

  **1.****什么是进程和线程？**

​    进程是一个应用程序（一个进程是一个软件），线程是一个进程中的执行场景/执行单元

​    一个进程可以启动多个线程

​    对于java程序而言，当输入代码后，会启动JVM，此时JVM就是一个进程，会先启动一个main方法的主线程

​      JVM又再启动一个垃圾回收器线程

  **2.****进程和线程的关系**

​    进程可以比作某个公司，而线程是公司中的某个员工

​    注：进程A与进程B之间的内存独立并不共享

​      在java语言中，线程A和线程B的对内存和方法区内存共享，但是栈内存独立，一个线程一个栈，互不干扰，这叫做多线程并发

​    多线程的目的是为了提高处理效率

​    使用了多线程之后，main方法结束后程序也有可能程序不会结束，因为main方法结束只是主线程结束了，主栈空了，但是其他的栈[支栈]（线程）可能并未结束

  3.对于单核CPU而言，真的可以多线程并发吗？什么是真正的多线程并发？

​    a线程就执行a

​    b线程就执行b

​    a和b互不影响

​    这才是真正的多线程并发

​    CPU的核数相当于人的大脑，多核CPU可以在一个时间点上真正有4个进程并发进行，然而单核的不能真正多线程，但是可以给人多线程的感觉

​    对于单核CPU在某个时间点上只能处理一件事，但是CPU的处理速度极快，多个线程之间频繁切换执行，从而给人同时在做许多线程的错觉

  4.实现线程的方式（java支持多线程并且已经实现了，只需要继承即可）

​    （1）编写一个直接继承java.lang.Thread的类，重写其中的run方法，run方法必须写

​      class MyThread extends Thread{

​        public void run() {

​          //编写程序

​          //这段代码运行在分支线程[支栈]中

​         }

​      }

​      怎么创建线程对象？怎么启动线程？

​      MyThread mt = new MyThread();//新建一个分支线程对象，new就行了

​      mt.start();//调用线程对象的start方法启动线程

 

​      start方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码瞬间就结束了，这段代码只是为了开辟新的栈空间，开出来以后start方法就结束了，线程就启动成功了，启动成功的方法会自动调用run方法，由JVM自己调用，不需要我们手动调用，且run方法会在分支栈的底部(压栈)

​      run方法和main方法是平级的，main在主栈底部，run在支栈底部

​      run方法中的异常只能try  catch不能抛出，因为子类不能比父类抛出更多的异常

​      如果不调用start方法直接调用run，会导致一直单线程，无法并发

 

​    （2）编写实现java.lang.Runnable接口的类，实现run方法

​        在主方法中，创建分支线程对象时需要在构造方法中new一个Runnable对象

​        Thread mt = new Thread(new MyRunnable);

​        //创建一个可运行的对象并将其封装成一个线程对象

​        mt.start();

​        //启动线程

​        class MyThread implements Runnable{

​           public void run() {

 

​          }

​        //定义一个可运行的类

​    注：建议使用第二种方式，因为java只支持单继承，我们要养成面向接口编程的习惯

​      第二种方式同样可以采用匿名内部类方式

 

​    （3）实现Callable接口

​      这种方式实现的线程可以获取线程的返回值，前两种并不能获得线程的返回值

​        第一步：创建一个”未来任务类“对象,它位于java.util.concurrent包下，属于java的并发包

​            参数非常重要，需要给一个Callable的接口的实现类对象

​             FutureTask task = new FutureTask(new Callable() {

​             //匿名内部类，此时的call方法等价于run方法，只不过这个有返回值

​             public Object call() throws Exception {

​               return null;

​             }

​           });

​        第二步：创建一个线程对象

​            Thread t =new Thread(task);

​        第三步：启动线程

​            t.start();

​      注：怎么在主线程中获取t线程的返回值呢？

​        调用task的get方法即可，get方法的的执行，会导致当前线程的阻塞

​        Object obj = task.get();

​        这个方法会导致主线程出现阻塞，直到t线程的get方法结束获得结果以后，才会继续向下执行

 

​        优点：可以获得线程的执行结果

​        缺点：出现线程阻塞，效率不高

 

  **5.****线程的生命周期**

​    （1）刚刚new出来的线程对象叫做新建状态

​    （2）通过调用start方法可以进入就绪状态（可运行状态，代表此时线程具有抢夺CPU时间片（执行权）的权力）

​    （3）当一个线程抢夺到执行权时，就开始执行run方法，run方法的运行代表着线程进入运行状态

​    （4）当之前占有的CPU时间片用完后，会重新回到就绪状态继续抢夺执行权，当再次抢到的时候就重新进入run方法接着上一次的代码继续执行

​        线程在就绪状态和运行状态之间来回跳转叫做JVM的调度

​    （5）当run方法执行结束时，标志着线程进入死亡状态

​    （6）当线程在运行状态时，如果遇到了阻塞事件，比如Scanner等会进入到阻塞状态，会把已经抢到的未用完的时间片释放

​    （7）当阻塞畅通后叫做阻塞解除，会继续回到就绪状态抢夺时间片

  **6.****线程对象的名字？**

​    设置线程对象的名字：(主线程的默认名字是main，支线程默认的名字是 Thread-n  [有m个线程的话n = m-1])

​    void setName(String name);

 

​    获取线程对象的名字：

​    String getName();

 

​    获取当前的线程对象;(返回一个当前的Thread线程，谁执行run方法，谁就是当前线程)

​    static Thread currentThread();

​    举例：静态方法用类名调用

​        Thread t = Thread.currentThread();//t就是当前线程

  **7.****线程的阻塞**

​    （1）线程的sleep方法

​      static void sleep(long millis);

​      静态方法类名调用，参数是毫秒

​      让当前线程进入休眠状态（阻塞状态），放弃占有的CPU时间片，让给其他线程

​      举例：

​        Thread.sleep(1000);

​        //出现在哪个线程，哪个线程就会休眠

​      这个方法的效果：间隔一段特定的时间去执行一段特定的代码，每隔多久执行一次

​    （2）怎么叫醒正在睡眠的线程

​      这个不是中断线程的执行，而是终止线程的睡眠

​      引用.interrupt();

​      这个是终止了线程了睡眠，依靠了java的异常处理机制，这个方法一旦执行，睡眠的线程中的sleep语句就会出现异常，进入到catch语句中，报出

​        java.lang.InterruptedException: sleep interrupted这个异常，然后执行下面的代码

​        不想有异常报出就可以把catch中的语句注释掉就行

  **8.****终止一个线程**

​    （1）强行终止：

​      t.stop();

​      //不是终止睡眠，而是直接将线程干掉

​      //已过时，不建议使用

​      stop()方法缺点：

​        可能会容易丢失数据

​    （2）合理终止：

​      在线程类中声明一个布尔标记，如果为true，就执行try语句块，如果为false，就终止run方法

​      在主方法或者其他地方只需要调用线程引用.布尔标记=false 即可终止线程

  **9.****线程的调度（了解）**

​    （1）常见的线程调度模型

​      抢占式调度模型：哪个线程的优先级比较高，抢到的CPU时间片的概率就高一些（java采用的）

​      均分式调度模型：把CPU时间片平均分给每个线程，一切平等

​    （2）java中有哪些方法是和线程调度有关系的？

​      实例方法：

​      void setPriority (int newPriority);

​      设置线程的优先级

​      优先级高的线获得Cpu的时间片可能会多一些（但不完全是）

 

​      int getPriority ();

​      获取线程的优先级[最低优先级是1，默认优先级是5，最高优先级是10]

 

​       void join();

​      合并线程

​      假设有个t线程，有代码t.join();

​      表示当前线程进入阻塞，t线程执行，直到t线程结束，当前线程才可以继续[内存上不是栈合并了，而是出现了等待关系]

 

​      静态方法：

​      static void yield();[让位方法]

​      暂停当前正在执行的线程，并执行其他线程

​      yield方法的执行会让当前线程从“运行状态”回到“就绪状态”，并不是阻塞方法

​        在回到就绪以后还有可能再次抢到

  **10.****线程的安全****[****重点****]**

​    （1）这个是重点，因为我们的项目都是运行在服务器中，而服务器已经将线程的定义、线程对象的创建、线程的启动等都已经实现完了，这些代码我们不需要编写

​      重要的是你需要知道你的程序是放到多线程环境下运行的，同时你需要关注你的这些数据在多线程的环境下是否安全

​    （2）什么时候数据在多线程并发的环境下会不安全？

​       三个条件：

​        多线程并发

​        有共享数据

​        共享数据有修改的行为

​      满足以上三个条件就会存在线程安全问题

​    （3）怎么解决线程安全问题？[线程同步机制]

​      线程排队执行，不能并发，用排队执行解决线程安全问题

​        这种机制被称为线程同步机制

​        线程同步其实就是线程排队，不能并发，只不过是更专业一些

​      线程同步会牺牲一部分效率，没办法，数据安全是第一位的

​    （4）同步与异步编程模型

​      同步编程模型：线程a和线程b在某个执行时另一个必须等它执行完才可以执行，两个线程发生了等待关系，线程排队执行，效率较低

​      异步编程模型：线程a和线程b各自执行各自的，互不干扰，谁也不需要等谁，就是多线程并发，效率较高

​    （5）线程同步机制

​       语法：

​        synchronized(){

​          线程同步代码块;

​        }

​        synchronized()小括号中的数据是相当关键的，这个数据必须是多线程共享的数据，才能达到多线程排队效果

​       ()中写什么？[共享对象]

​        取决于你想让哪些线程同步

​        假设有1、2、3、4、5这5个线程同步，你只希望1、2、3排队，则必须在()中写一个1、2、3共享的对象，而这个对象对于4和5而言不是共享的

​        ()中的对象可以是字符串"abc",此时所有线程都会同步，但是不可以是null

​       java中怎么保证线程同步机制？

​        在java中，任何一个对象都有“一把锁”，（其实这把锁就是一个标记，只是把它叫做锁）一个对象一把锁，n个对象n把锁

​          假设a和b线程并发，必定在执行代码时有一先一后，先线程遇到synchronized关键字以后会自动找后面共享对象的对象锁，找到后会占有

​          这把锁，然后执行同步代码块中的代码，在程序执行中一直占有这把锁，直到同步代码块执行结束才会释放这把锁，其他的线程才能重新占有这把锁

​          这样就达到线程排队执行

​         注：共享对象一定要选好，一定是需要排队线程的共享的对象

​        当且仅当一个线程遇到synchronized关键字后，就会放弃已有的时间片，进入到锁池(lockpool)中去找共享对象的对象锁，有可能找到了，有可能没找到

​          没找到的话就会在锁池中等待，如果找到了就会进入就绪状态继续抢夺CPU时间片

​          其实进入锁池可以理解为一种阻塞状态

​       同步代码块越小效率越高，因此如果扩大同步的范围，程序的效率就会降低

​       synchronized关键字可以用在实例方法上，但是此时的共享对象一定是this，无法更改指定，所以这种方法不灵活

​        除此之外，缺点还有如果该关键字出现在方法上，同步的是整个方法体，可能会无故扩大同步范围，降低效率，这种方式不常用

​        除此之外，优点是代码量减少，显得更加简洁，如果共享的对象就是this并且需要同步的代码块就是整个方法，建议用这种方式同步

​       总结：Synchronized的三种写法

​          第一种：同步代码块[灵活]

​          synchronized(线程共享对象){

​            同步代码块;

​          }

 

​          第二种：在实例方法上使用synchronized

​          表示共享对象一定是this并且同步代码块是整个方法体

 

​          第三种：在静态方法上使用synchronized

​          表示找类锁

​          类锁永远只有一把，就算创建了n个对象，类锁也只有一把，而对象锁是n个对象n个锁，类锁是用来保证静态变量的线程安全的

​    （6）java中有三大变量

​      实例变量[堆]：可能存在线程安全问题

​      静态变量[方法区]：可能存在线程安全问题

​      局部变量[栈]：永远不会出现线程安全问题，因为局部变量不共享（一个线程一个栈）

 

​      如果使用局部变量的String，建议使用StringBuilder，因为局部变量不存在线程安全问题，使用StringBuffer效率较低

​      ArrayList线程不安全

​      Vector线程安全

​      HashMap HashSet线程不安全

​      HashTable线程安全

​    （7）死锁概述

​      当出现死锁的时候，程度既不会出现异常，也不会出现错误，这种情况最难调试

​      死锁代码示例

 

​      public class Thread06 {

​        public static void main(String[] args) {

​          Object o1 = new Object();

​          Object o2 = new Object();

​          Thread t1 = new MyThread04(o1,o2);

​          Thread t2 = new MyThread05(o1,o2);

​          t1.start();

​           t2.start();

​        }

​      }

​      class MyThread04 extends Thread{

​        Object o1;

​        Object o2;

​        public MyThread04(Object o1,Object o2){

​          this.o1 = o1;

​          this.o2 = o2;

​        }

​        public void run() {

​          synchronized (o1){

​            try {

​              Thread.sleep(1000);

​            } catch (InterruptedException e) {

​              e.printStackTrace();

​            }

​            synchronized (o2){

​          }}}}

​      class MyThread05 extends Thread{

​        Object o1;

​        Object o2;

​        public MyThread05(Object o1,Object o2){

​          this.o1 = o1;

​          this.o2 = o2;

​        }

​        public void run() {

​          synchronized (o2){

​            try {

​              Thread.sleep(1000);

​            } catch (InterruptedException e) {

​              e.printStackTrace();

​            }

​            synchronized (o1){

​          }}}}

 

​      因此Synchronized关键字最好在开发中不要嵌套使用，因为一不小心就死锁了

​    （8）开发中真正解决线程安全的步骤方法

​      使用synchronized关键字会使得程序效率降低，用户体验差，不得已下再使用这个关键字

​      第一种方案：

​        使用局部变量代替实例变量和静态变量

​      第二种方案：

​        如果必须是实例变量，可以考虑创建多个对象，这样实例变量的内存就不共享了（一个线程对应一个对象，n个线程对应n个对象）

​      第三种方案：

​        如果前两种都不适合，这个时候就只能使用synchronized关键字

  **11.****守护线程****[****后台线程****]**

​    （1）java中线程分为两大类：

​      用户线程和守护线程

​      代表：守护线程：垃圾回收线程

​    （2）守护线程特点：

​      一般守护线程是一个死循环

​      所有的用户线程只要结束，守护线程自动结束

​      注：主线程main是一个用户线程

​    （3）守护线程用在什么地方？

​      每天0点系统自动备份

​      这里需要使用定时器，并且我们可以把定时器设置为守护线程

​      如果所有的用户线程结束了，那么守护线程就自动退出，没有必要进行数据备份了

​    （4）守护线程的语法[守护线程一般都是死循环，while(true)]

​      守护线程引用.setDaemon();

​      //此时如果主线程（用户线程）结束，那么守护线程就会直接结束

 

  **12.****定时器**

​    （1）定时器的作用

​        间隔特定的时间，执行特定的程序

​        举例：每周进行银行账户的总账操作，每天进行数据的备份操作

​        实际的开发中，定时器的需求是很常见的，在java中可以采用多种方法实现

​          1.sleep方法设置睡眠时间，每到一个特定时间点醒来，执行任务，这种方式最为原始，比较低级

​          2.在java的类库中已经写好了一个定时器类，java.util.Timer,可以直接拿来用，这种方式也很少用，因为现在很多高级框架都支持定时任务

​          3.Spring框架中提供了SpringTask框架，这个框架只需要进行简单的配置，就可以完成定时器的任务

​    （2）实现定时器

​      代码举例：

 

​        public static void main(String[] args) throws ParseException {

​          //使用定时器指定定时任务

​          //创建定时器对象

​          Timer timer = new Timer();

​          /*Timer timer = new Timer(true);

​          这样用构造方法，代表此时timer为守护线程*/

​          //获取当前时间

​          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

 

​          Date time = new Date(sdf.parse("2020-10-24 08:08:08"););

​          //指定定时任务

​          //timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);

​          timer.schedule(new LogTimerTask(),time,1000 * 10);

​        }

​      }

​        //由于定时任务类是抽象类，所以需要自己写一个类来实现这个定时任务类

​        //假设一个记录日志的定时任务

​      class LogTimerTask extends TimerTask {

​          public void run(){

​            //编写需要执行的任务

​          }

​        }

  **13.Object****类中的****wait****和****notify****方法（生产者和消费者模式）**

​    （1）wait和notify方法不是线程对象的方法，是java中任何一个对象都有的方法，因为这两个方法是Object类自带的

​        这两个方法不是由线程对象调用的，而是通过java对象调用的，即：t.wait();等是错误的

​    （2）wait()方法的作用

​        Object o = new Object();

​        o.wait();

​        表示：让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止

​          因此，o.wait();的调用，会使得“当前线程（正在o对象上活动的线程）”进入等待状态

​          同时会释放之前占有的o对象的锁

​    （3）notify()方法的作用

​         Object o = new Object();

​        o.notify();

​        表示：让正在o对象上等待的线程进入活动状态

​          因此，o.notify();的调用，会使得“当前线程（正在o对象上等待的线程）”进入唤醒状态

​          但是该方法只会通知，不会释放之前的占有的o对象的锁

​    （4）notifyAll()方法

​        唤醒在o对象上等待的所有线程

 

​    注：没有waitAll方法，wait方法和notify方法时建立在synchronized线程同步的基础上的

​    （5）什么是消费者和生产者模式

​      生产线程负责生产，消费线程负责消费

​      生产线程和消费线程要达到均衡

​      这是一种特殊的业务需求，需要使用wait和notify方法

 

**第十三部分** **反射机制**

  （1）反射概述

​    通过java中的反射机制可以操纵字节码文件（代码片段、class文件），可以读、改字节码文件

​    反射机制的相关类位于java.lang.reflect.*包下

​    反射机制相关的重要类

​      java.lang.Class           代表整个字节码文件，代表整个类

​      java.lang.reflect.Method      代表字节码中的方法字节码，代表类中的方法

​      java.lang.reflect.Constructor    代表字节码中的构造方法字节码，代表类中的构造方法

​      java.lang.reflect.Field       代表字节码中的属性字节码，代表类中的成员变量

  （2）三种获得java.lang.Class实例的方法

​    第一种：Class c1 = Class.forName("java.lang.String"["完整类名带包名"]);  //此时c1代表的就是java.lang下的String.class字节码文件

​       注意：forName()是一个静态方法，需要用类名Class去调用

​         方法的参数是一个字符串

​         字符串需要是一个完成的类名

​         完整类名必须包含包名。java.lang包名也不能省略

​    第二种：通过对象的getClass();方法获得对应类的class  [对象.getClass()]

​      java中任何一个对象都有getClass()方法，因为这个方法是Object老祖宗自带的

​      String s = "abc";

​      Class x = s.getClass();   //x代表String.class字节码文件，x代表String类型

 

​      System.out.println(c1 == x);    //结果是true

​    第三种：Class c = 任何类型.class;

​      java中任何一种类型包括基本数据类型，都有.class属性

​       Class z = String.class;   //z代表String类型

  （3）通过反射机制获得Class以后通过Class实例化对象

​      可以用类名引用.newInstance();方法，这个方法底层会调用类的无参数构造方法，从而完成对象的创建

​      因此如果对象构造方法只有有参的，就会出现异常，叫做实例化异常 java.lang.InstantiationException

​        try {

​          //获得Class

​          Class c = Class.forName("Student");

​          //利用newInstance()方法来实例化对象,是Student实例

​          Object obj = c.newInstance();

​        } catch (ClassNotFoundException e) {

​          e.printStackTrace();

​        } catch (IllegalAccessException e) {

​          e.printStackTrace();

​        } catch (InstantiationException e) {

​          e.printStackTrace();

​        }

​      }

 

​      这样的好处是配合properties的io流可以java代码只写一遍，在不改变java源代码的基础上，可以做到不同对象的实例化，非常长灵活

​        符合OCP原则，对扩展开放，对修改关闭

  （4）如果只想要一个类的静态代码块执行，不执行其中的其他代码，那么需要这样写代码

​      Class.forName("完整类名加包名");

​      这个方法会导致类加载，类加载时静态代码块执行

  （5）关于文件路径的问题

​      在IDEA中的默认路径是project的根，如果使用相对路径，就会有移植性差的缺点，只能在IDEA中找得到文件，这个代码离开IDEA，相对路径就无效了

​      比较通用的路径，即使代码移植了，这样编写依旧通用

​        注：使用以下通用路径的前提是：这个文件在类路径（凡是在src下的都是在类路径下都叫类路径，src是类的根路径）下

​        //            当前线程对象.  获取当前线程的类加载器. 从类的根目录下获取资源.

​        String path = Thread.currentThread().getContextClassLoader().getResource([从类的根目录下开始加载]"文件名").getPath();

​        通过以上代码，可以获得该文件的绝对路径String path，这种方式是绝对通用的，不论是Linux还是windows

 

​        直接以流的形式返回绝对路径

​        InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream("从src开始的相对路径");

  （6）资源绑定器

​      java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容

​      使用以下这种方式的时候，属性配置文件xxx.properties必须放到类路径下

​      //资源绑定器，只能绑定xxx.properties文件，并且这个文件必须在类路径下

​      //文件扩展名也必须是properties，且写路径的时候，路径后面的扩展名不能写

​      ResourceBundle bundle = ResourceBundle.getBundle("xxx");

​      //传一个key就可以返回获得value的值

​      String className = bundle.getString([从类目录开始找]"className");

​      System.out.println(className);

  （7）类加载器概述

​    什么是类加载器？

​      专门负责加载类的命令/工具

​      classLoader

​    JDK中自带了三个类加载器

​      启动类加载器：专门负责加载jre\lic\rt.jar   rt.jar中都是JDK最核心的类库.

​      扩展类加载器：[启动类加载器加载不到的时候才启用]专门负责加载jre\lib\ext\*.jar中的class文件

​      应用类加载器：[前两个都没有找到]专门负责加载 classpath下的jar包（class文件）

​    双亲委派机制[安全机制]

​      启动类加载器是父

​      扩展类加载器是母

​      优先从启动类加载类，找不到再从扩展类加载类

​      如果都查找不到，才会考虑从应用类加载器中加载，直到加载到为止

  （8）反射属性field[field 就是 属性]

​      第一：获取整个类

​        Class studentClass = Class.forName("Student");

 

​      第二：获取类中的所有 public 的field，调用类的getFields方法,返回一个field数组

​        Field[] f = studentClass.getFields();

 

​      第三：获取类中所有的field，调用类的getDeclaredField方法，返回一个field数组

​         Field[] fs = studentClass.getDeclaredFields();

 

​      第三：获得取出的field的名字,调用field对象的getName()方法，返回一个String

​        field[i].getName();

​        //类同样有getName方法，studentClass.getName();会返回String类型的带包名的完整类名

​        //类同样有getSimpleName方法，studentClass.getSimpleName();会返回String类型的简类名（不带包名）

 

​      第四：获得取出的field的类型，调用field对象的getType()方法，返回一个Class,调用Class的getName或者getSimpleName方法可以获得数据类型

​        Class fieldName = field[i].getType();

​        String fName = fieldName.getName();

​        //合并以上代码就是  System.out.println(field[i].getType().getSimpleName());

 

​      第五：获得取出的field的修饰符列表，调用field对象的getModifiers()方法，返回一个int数据，再调用Modifier这个类中的静态方法toString即可获得真实的修饰符列表

​        System.out.println(Modifier.toString(field[i].getModifiers()));

 

​      第六：通过反射访问对象属性

​          给属性赋值

​          获取属性的值

​          public static void main(String[] args) throws Exception {

​            Class studentClass = Class.forName("Student2");

​            Object obj = studentClass.newInstance();//obj就是student对象

​            //获取其中的no属性,需要加入属性名称参数

​            Field f = studentClass.getDeclaredField("no");

​            //给Obj这个student对象的no属性赋值

​            f.set(obj,222);//给obj对象的no属性赋值222

​            /*

​            三个要素：

​              1.obj对象

​              2.no属性

​              3.222这个值

​              虽然反射机制让代码复杂了，但是更加灵活了，这是值得的

​            */

​            //读取属性的值

​            /*

​            \* 两个要素：

​            \*  获得obj对象的no属性*/

​            System.out.println(f.get(obj));

 

​           注：这里对属性的访问是不可以访问私有属性的，如果要访问私有属性，需要用

​            f.setAccessible(true);来打破封装，这也是反射机制的缺点，易于出现安全隐患

  **9.****可变长度参数**

​    （1）语法：类型...标识符

​      举例：int...args[三个点]

​          m();

​          m(1);

​          m(102,12,34);

​          //以上都可以正常执行

​        public static void m(int...args){

​          System.out.println("begin");}

​    （2）可变长参数要求的参数是0-n个

​    （3）可变长参数在参数列表中必须最后一个位置上，且只能有一个

​    （4）可变长参数可以看做一个数组来对待，其实就是一个数组

  **10.****反射****Method**

​    获取类中所有的Method（方法），调用类的getDeclaredMethod方法，返回一个Method数组

​      Method[] ms = studentClass.getDeclaredMethods();

​    获取方法的修饰符列表（一个方法的参数可能有多个），调用parameterType方法,返回一个Class数组

​      Class[] parameterType = method.parameterType();

​     获取方法的其他信息和获得属性的方法是一致的

  **11.****使用反射机制调用方法**

​    public class Reflect04 {

​      public static void main(String[] args) throws Exception{

​        Class test = Class.forName("test");//拿到类名

​        Object obj = test.newInstance();//new 一个对象

​        //获取方法

​        Method m1 = test.getDeclaredMethod("m1",null);

​        Method m2 = test.getDeclaredMethod("m2",int.class);

​        //调用方法

​        /*

​        \* 要素分析：

​        \*  1.对象

​         \*  2.方法名

​        \*  3.实参列表

​        \*  4.返回值

​        \* */

​        //以下是最重要的方法，包含了以上四要素，obj是对象，10是实参列表，returnValue是返回值，m2是方法名

​        Object returnValue = m2.invoke(obj,10);

​        System.out.println(returnValue);//m2 begin  10

​     }}

​    class test{

​      public static void m1(){

​        System.out.println("m1 begin");

​      }

​      public static int m2(int i){

​        System.out.println("m2 begin" );

​        return i;

​      }}

  **12.****通过反射一个类的****Constructor(****构造方法****)****后创建一个类**

​      public class Reflect05 {

​        public static void main(String[] args) throws Exception{

​          Class vipClass = Class.forName("vip");

​          Object obj = vipClass.newInstance();//调用无参数构造方法创建类

​          //调用有参数的构造方法怎么办？

​          //第一步：先获取到这个有参数的构造方法

​          Constructor c = vipClass.getDeclaredConstructor(int.class,String.class,String.class,boolean.class);

​          //第二步：调用构造方法new对象

​          Object obj2 = c.newInstance(110,"水原千鹤","20011024",true);

​          System.out.println(obj2);

​        }

​      }

​      class vip{

​        int no;

​         String name;

​        String birth;

​        boolean sex;

​        public vip(){

 

​        }

​        public vip(int no){

​          this.no = no;

​        }

 

​        public vip(int no, String name, String birth, boolean sex) {

​          this.no = no;

​          this.name = name;

​          this.birth = birth;

​          this.sex = sex;

​        }

  **13.****获取父类以及父接口**

​    （1）获取一个类的父类

​      调用getSuperclass()方法，返回一个Class

​      以String为例

​      Class stringClass = Class.forName("java.lang.String");

​      Class superClass = stringClass.getSuperclass();

​    （2）获取一个类的接口（一个类可以有多个接口）

​      调用getInterfaces()方法，返回一个Class数组

​      以String为例

​      Class stringClass = Class.forName("java.lang.String");

​      Class[] interfaces = stringClass.getInterfaces();

 

**第十四部分** **注解**

  **1.****注解概述**

​    （1）注解annotation是一种引用数据类型，编译后生成class文件

​    （2）怎么定义注解？

​      语法格式：

​       [修饰符列表] @interface 注解类型名{}

  **2.****注解怎么用？用在什么地方？**

​    （1）注解使用的语法格式：

​        @注解类型名

​    （2）注解可以出现在哪里？

​        类        属性        方法        变量        注解等

​       默认情况下，注解可以出现在任何地方

  **3.JDK****自带了哪些注解？**

​    （1）Deprecated

​      不鼓励程序员使用被这样注解的元素，因为通常它是很危险或存在更好的选择

​      表示被注解的东西已经过时了，主要是向其他程序员传达告知该元素已经过时，有更好的解决方案

​    （2）Override[标识性注解，给编译器做参考的]

​      表示一个方法声明打算重写超类中的另一个方法声明

​      只能注解方法，是给编译器参考的，和运行阶段无关，凡是java中方法有这个注解，编译器都会编译检查，如果该方法不是重写父类方法，就会编译报错

​    （3）SuppressWarnings

​      指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告

  **4.****元注解**

​    （1）什么是元注解？

​      用来标注注解类型的注解叫做元注解

​    （2）常见的元注解

​      Target

​        这是一个元注解，用来标注被标注的注解可以出现在哪些位置上

​        举例：

​        @Target(ElementType.METHOD)

​        表示被注解的注解只能出现在方法上

​      Retention

​        这是一个元注解，用来标注被标注的注解最终保存在哪里

​        举例：

​        @Retention(RetentionPolicy.SOURCE)

​        表示被标注的注解只被保留在java源文件中

​        @Retention(RetentionPolicy.CLASS)

​        表示被标注的注解被保留在class文件中

​        @Retention(RetentionPolicy.RUNTIME)

​        表示被标注的注解被保留在class文件中并且可以为反射机制所读取

  **5.****自定义注解**

​    （1）在注解中定义属性

​        String name();

​        这是一个注解中的name属性，并不是方法

​    （2）如果注解中有属性，必须给属性赋值

​        语法：

​        @注解类名(属性名=属性值)

​        举例：

​        @annotation02(name = "水原千鹤")

 

​        如果不想给属性赋值，可以在注解中加入属性的默认值，用default关键字

​        举例：

​        String name() default "xxx";

 

​        注：当注解只有一个属性并且属性的名字叫做value，那么在属性赋值的时候可以省略value不写

​          一些源代码中会有这种情况，出现以后我们就知道是有且只有一个属性value

​    （3）注解中的属性都可以是哪些类型？

​        八种基本类型

​        String         Class        枚举        以及以上提到的数组形式

​        注：如果数组中只有一个元素，那么在给属性赋值时的大括号可以省略

​    （4）自定义注解举例：

​      @Target({ElementType.TYPE,ElementType.METHOD})//只允许被注解的注解可以标注类、方法

​      @Retention(RetentionPolicy.RUNTIME)//希望被注解的注解可以被反射

  **6.****反射注解**

​    （1）先获取这个类

​      Class c = Class.forName("注解修饰的类名");

​    （2）判断这个类是否有xxx注解

​      c.isAnnotationPresent(xxx.class);//如果有xxx这个注解，那么就返回true，反之则返回false

​    （3）如果这个类有xxx注解，就获取这个注解对象

​      xxx x = (xxx)c.getAnnotation(xxx.class);

​    （4）获取注解对象的属性[和调接口没有什么区别]

​      System.out.println(x.属性名);

​    注：如果要反射方法的注解，一样的步骤，只不过是在获取这个类以后还需要用getDeclaredMethod方法来获取被注解的方法

 