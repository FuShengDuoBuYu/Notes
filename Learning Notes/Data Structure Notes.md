# Data Structure Notes

## 第一部分	绪论

 1.数据结构是一门研究非数值计算(表,树,图)的程序设计中计算机的操作对象以及他们之间关系和操作的学科

 2.数据:数值型的数据,非数值型的数据

 3.数据元素(元素,记录,节点,顶点):是数据的基本单位,在程序中通常作为一个整体进行考虑

 4.数据项:构成数据元素的最小单位

 5.大小关系:数据>数据元素>数据项

 6.数据对象:性质相同的数据元素的集合,是数据的子集

 7.数据结构:数据元素相互之间的关系(带结构的数据元素的集合),包含逻辑结构,物理结构以及运算和实现

​     逻辑结构是数据结构的抽象,存储结构是数据结构的实现

​     逻辑结构:

​         线性结构(有且只有一个开始和终端节点,每个节点最多只有一个直接前趋和一个直接后继):线性表,栈,队列,串

​         非线性结构(一个节点可能有多个直接前趋和多个直接后继):树,图

​     存储结构:

​         顺序存储结构:连续的存储单元依次存储数据元素[数组]

​         链接存储结构:任意的的存储单元存储数据元素[指针链表]

​         索引存储结构:存储节点时,再建立附加的索引表

​         散列存储结构:根据节点的关键字直接计算出该节点的存储地址

 **8.数据类型:值的集合+值集合上的一组操作**

 **9.抽象数据类型(ABstract Data Type),可以理解为类**

​     表示:可用(D,S,P)表示,其中D是数据对象,S是D是上的关系集,P是对D的基本操作集

​     定义格式:

​         ADT 抽象数据类型名{

​             数据对象:<数据对象的定义>

​             数据关系:<数据关系的定义>

​             基本操作:<基本操作的定义>

​         } ADT抽象数据类型名

 **10.算法的特性:**

​     有穷性,确定性,可行性,输入(零个或多个),输出(一个或多个)

 **11.算法设计的要求:**

​     正确性,可读性,健壮性(鲁棒性),高效性

 **12.算法分析**

​     算法效率(时间效率和空间效率)越高,算法越好

​     时间效率的度量:

​         执行一种简单的操作(赋值,比较,移动等)所需的时间与简单操作次数的乘积

​         可以转化为算法中所有语句的执行次数,即每条语句的频度之和

​         我们用算法的(渐进)时间复杂度代表算法的时间效率,即O(f(n));

​         一般而言,时间复杂度是由嵌套层次最深的语句决定的

​     空间效率的度量:

​         算法所需要的存储空间的容量

​         我们用算法的(渐进)空间复杂度代表算法的空间效率,即S(f(n));

 **13.时间复杂度T(n)按照数量级递增顺序为:**

​     常数阶<对数阶<线性阶<线性对数阶<平方阶<立方阶<K次方阶<指数阶

---

## 第二部分 线性表

 **1.线性表的定义和特点**

​     (1)线性表是由n(n>+=0)个数据元素(结点)a1,a2等an组成的有限序列

​         n为表的长度,n为0时叫做空表

​     (2)同一线性表中的元素必有相同特性,数据元素之间关系为线性关系

​         都是一对一的对应关系

​     (3)线性表是一种典型的线性结构

​     (4)顺序存储结构有问题,包括分配不灵活,空间复杂度高等

​     (5)线性表中的数据类型可以是简单类型,也可以是复杂类型

​     (6)在计算机中,线性表有两种基本存储结构

​         顺序存储结构(数组)和链式存储结构(链表)

 **2.线性表的顺序表示和实现**

​     (1)线性表中第一个元素的存储地址,被称作线性表的起始地址(基地址)

​     (2)线性表中的所有数据必须依次存储,地址连续,没有空出存储单元

​     (3)寻找其中元素的时间复杂度为O(1),任意元素可以随机存取

​     (4)可以使用一维数组实现顺序表,线性表长可变,但是数组长度不可动态定义,此时可以用一个变量来表示顺序表的长度属性

​     (5)线性表定义的模板

​         \#define LIST_INIT_SIZE nnnn

​         typedef struct{

​             Elem Type elem[LIST_INIT_SIZE];

​             int length;//当前的长度

​         } SqList;

​     (6)顺序表的平均查找长度(Average Search Length): (n+1)/2

​     (7)顺序表的插入,查找,删除的顺序方法的时间复杂度都是O(n)

​     (8)顺序表的实现实际上就是数组的实现,因此此处不再记录

​     (9)顺序表的优缺点:

​         优点:存储密度大;可以随机存取任意元素

​         缺点:插入或删除时需要移动大量数据;浪费存储空间;静态存储,元素个数不能自由扩充

 **3.线性表的链式表示和实现**

​     (1)每个结点需要包含数据域和指针域两个部分,指针域也被成为链,若干个结点就构成了链表

​     (2)单链表是由头指针唯一确定的,因此单链表可以用头指针的名字L来命名

​     (3)当链表有头结点时,头指针指向头结点,头结点的下一个结点即首元结点才是第一个存储数据的结点

​     (4)设置头结点的好处:便于首元结点的处理;便于空表的非空表的统一处理

​     (5)相邻的结点物理上未必相邻,访问不同的结点花费时间也有所不同,叫做顺序存取法

​     (6)对带头结点的单链表:

​         指向头结点: p=L;

​         指向首元结点: p=L->next

​     (7)从链表中取第i个元素,必须从头指针出发,顺着next逐步向下查找,直到找到第i个为止,不是随机存取结构

​     (8)本质上就是单链表的实现,因此此处不再记录

​     (9)单链表的查找,插入,删除的时间复杂度都是O(n)

​     (10)循环链表的优点是从表中任意个节点出发都可以找到表中其他结点

​     (11)双向链表具有对称性,即p->next->prior == p == p->prior->next

​     (12)链式存储的优缺点:

​         优点:结点空间可以动态申请和释放;插入和删除数据时不需要移动数据

​         缺点:指针域需要额外的大量空间,存储密度小;是非随机存取结构,增加了算法的复杂度

 **4.栈(stack)**

​     (1)定义与特点

​         定义:限定仅在一端进行插入和删除的线性表

​         特点:先进后出,后进先出

​     (2)表尾被称为栈顶(top),表头被称为栈底(base)

​     (3)出栈(弹栈):POP 入栈(压栈):PUSH

​     (4)当栈以顺序存储时,叫做顺序栈,以链式存储时,叫做链栈

​     (5)顺序栈的表示和实现(较为简单,不再赘述)

​         (a)往往设置top指针,指向栈顶元素之上的下标地址,设置base指针,指向栈底元素的地址

​         (b)当top == base时,代表是空栈的标志,当top-base == stacksize时,代表是满栈的意思

​         (c)上溢(overflow):栈已满,仍压栈 下溢(underflow):栈已空,仍弹栈

​             通常上溢是一个错误,使得问题无法处理,但是下溢一般是一种结束条件,即问题处理结束

​     (6)链栈的表示和实现(较为简单,不再赘述)

​         (a)链栈中的指针的方向和链表中的指针方向相反,即an指向an-1

​         (b)链表的头指针就是栈顶,不需要头结点

​         (c)基本没有满栈的情况,空栈相当于头指针指向空

​     (7)栈与递归

​         (a)递归方法出现于:

​             递归定义的数学函数;有递归特性的数据结构;可递归求解的问题

​         (b)分治法求递归问题,一般需要有基本项(递归结束条件)和归纳项(调用递归)

​         (c)详见java笔记中的递归,更加清楚

​         (d)递归的优缺点:

​             优点:结构清晰,可读性好

​             缺点:时间开销大

​         (e)递归都可以转化为循环结构

 5.队列(queue)

​     (1)定义与特点

​         定义:先进先出的线性表,只能在表尾插入.在表头删除

​         特点:先进先出,头删尾插

​     (2)入队和出队

​     (3)有顺序队或者链队,其中以循环顺序队列最常见

​     (4)解决队列假上溢的方法是引入循环队列,可以用求模运算解决

​     (5)由于引入循环队列以后,队空和队满时都有front == rear,因此有以下解决方法:

​         设置另一个标志标记空还是满;另设一个变量记录元素个数;少用一个元素空间;

​         一般我们用少用一个元素空间来解决,即最顶上的那个空间空出来

​         那么此时的对队空: front == rear 队满:(rear+1)%MAXQSIZE == front

​     (6)若用户无法估计所用队列的长度,则适合用链队列

 6.串(String)

​     (1)零个或者多个任意字符组成的有限序列,如S = "abcdef";

​     其中S为串名,abcdef为串值,长度为串长

​     (2)所有的空串都是相等的

​     (3)串用顺序存储时叫顺序串,链式存储为链串(操作方便但是存储密度低,因此往往将多个字符放在同一个结点来克服缺点,这样的结点叫做块,这样的结构叫块链)

​     (4)串的匹配算法(求一个子串在主串中第一次出现的位置):

​         (a)BF算法(Brute-Forth):

​             从主串的第一个字符开始依次和子串中的字符进行匹配

​             也即该方法为暴力比对破解法

​         (b)KMP算法

​             较为复杂

 7.特殊矩阵的压缩存储(为相同的非零元素只分配一个空间,不给零元素分配空间)

​     (1)矩阵的常规存储:

​         将矩阵描述为二维数组,可以进行数据的随机存取,运算简单

​     (2)对称矩阵的压缩

​         只存储上(下)三角的元素,共占用n(n+1)/2个空间,以行序为主序将元素存放在一个一维数组中,即a11,a21,a22,a31,a32...

​     (3)三角矩阵的压缩

​         重复元素c共享一个元素空间,一共占用n(n+1)/2 + 1个元素空间,同样存储在一个一维数组中

​     (4)对角矩阵的压缩

![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

(5)稀疏矩阵的压缩

​         顺序方法:上图

​             利用三元组(i,j,aij)来记录,其中i表示行,j表示列,aij表示值的大小

​             被称为三元组顺序表(有序的双下标法),便于进行以行处理的矩阵运算,但是不能随机存取

​         链式方法:上图

​             十字链表,可以灵活的插入和删除,将每个非零元素都有row,col,value,down和right五个元素

​             其中right表示同一行的下一个非零元素,down链接同一列的下一个非零元素

​    8.广义表

​         (1)表中的元素也可能是另一个表,记作LS为表名,n为表的长度,ai为表的元素

​         (2)表头:a1     表尾:除了表头以外的其他元素的和的子表,即(a2,a3…an)

​         (3)广义表的长度:最外层包含的元素个数

​             广义表的深度:广义表展开后所含括号的重数,如(a,(b,c))深度为2

​         (4)广义表是线性表的推广,线性表是广义表的特例

---

## 第三部分	非线性表---树与二叉树

1.树:n个结点的有限集,其表示形式有嵌套集合和凹入表示,广义表等等

​    2.结点的度:结点拥有的子树的个数       树的度:各结点度的最大值

​    3.树的深度(高度):树中结点的最大层次

​    4.有序树:书中结点的各子树从左到右有次序 无序树:各子树无次序

​    5.二叉树的子树有左右之分,次序不可颠倒,可以有空的左右子树,即使二叉树只

​    只有一个子树,也需要区分是左子树还是右子树

​    6.二叉树不是树的特殊情况,他们是两个概念,因树是不分左右子树的

​    7.二叉树的性质:

​         (a)在二叉树的第i层最多有2^(i-1)个结点,最少有1个结点

​         (b)深度为k的二叉树最多有2^k – 1个结点,最少有k个结点

​         (c)如果叶子数为m,度为2的结点是n,则m = n + 1

8.满二叉树:一个深度为k且有2^k-1个结点的二叉树,即每层结点全都存在,叶子结点全在最底层的二叉树

9.完全二叉树:编号和满二叉树的编号位置完全一致的树

​    注:在满二叉树中,从最后一个结点开始,连续去掉任意个结点后,一定是一个完全二叉树

10.完全二叉树的性质:

​    (a)具有n个节点的完全二叉树的深度为|_lgn_| + 1    (|__|为向下取整)

​    (b)当对一个完全二叉树编号后,对于编号为i的结点,其双亲的编号为|_i/2_|,左孩子结点为2i,右孩子编号为2i+1

11.二叉树的存储结构

​    (a)顺序存储:按照满二叉树的结点层次编号,依次在数组存放二叉树的数据元素

​         缺点:对单支树的存储空间有大量的浪费,只适合存满二叉树和完全二叉树

(b)链式存储:二叉链表,也即每个结点有Lchild,data和Rchild三个部分,分别是左孩子的地址,数据和右孩子的地址

 

​    注:在n个结点的二叉链表中,有n+1个空指针域

​    当链表中再增加一个指向双亲的指针域时,就叫做三叉链表

​    12.二叉树的遍历

​         (a)先序遍历

​             先访问根结点,再遍历左子树,再遍历右子树

​         (b)中序遍历

​             先遍历左子树,再访问根节点,在遍历右子树

​         (c)后序遍历

​             先遍历左子树,再访问右子树,再访问根结点

(d)若二叉树中各结点的值不同,则其先序遍历,中序遍历和后序遍历都是唯一的,有先序和中序或者中序和后序,就可以确定唯一的二叉树

(e)如果去掉输出语句,从递归的角度来看,三种遍历算法是完全一样的,或者说,其访问路径是一样的,只是访问结点的时机不同

(f)每个遍历算法的时间效率是O(n)[每个结点只访问一次],空间效率也是O(n)[栈占用的最大的辅助空间]

(g)非递归的遍历算法(中序遍历为例)

​    建立一个栈

​    根结点进栈,遍历左子树

​    根结点出栈,输出根结点,遍历右子树

​    

 

 

 

​         (h)二叉树的层次遍历

​             对于一个二叉树,从根结点开始,按照从上到下,从左到右的顺 序访问每一个节点

​             思路:

​             先将根结点进队

​             当队列不空时,执行以下循环:

​             从队列中出列一个结点*p,访问它,如果它有左(右)孩子结点, 就将左(右)孩子结点进队

 

​         (i)构建二叉树(先序遍历为例)[下图]

​         (j)复制二叉树[上图]

​             使用递归,如果是空树,就递归结束,否则,就申请新的结点空间,复制根结点,然后依次递归的复制左右子树

​         (k)计算二叉树的深度

​             如果是空树,则深度为0

​             否则,递归计算左子树的深度记作m,递归计算右子树的深度记作n,二叉树的深度为max(m,n)+1

​         (l)计算二叉树的结点总数

​             如果是空树,则结点个数为0

​             否则,结点个数为左子树的结点个数+右子树的结点个数+1

13.线索二叉树(threaded binary tree)与树和森林

​    (a)线索二叉树:利用二叉链表的空指针域:

​         如果某个结点的左(右)孩子为空,则将空着的左(右)孩子指针域改为指向其前驱(后继)[对应某种遍历顺序]

​         这种改变指向的指针被称为”线索”,有线索的二叉树就叫线索二叉树

​         因此最后的结点结构:

​         lchild ltag data rtag rchild

(b)由于加了线索后的二叉树其仍然有遍历序列中的第一个和最后一个结点各有一个空指针,因此我们增加一个头节点,这个头节点是这样的:

(c)树的存储结构

  (1)双亲表示法[上图]:定义结构数组,存放树的结点,每个结点含两个域,数据域[存储结点本身信息]和双亲域[双亲结点在数组中的位置]

​       特点:找双亲容易,但是找孩子难

(2)孩子链表[下图]:把每个结点的孩子结点排列起来,看成是一个线性表,用单链表存储,那么n个结点就有n个孩子链表,将n个头指针组成一个用顺序表(结构数组)的线性表存储

  特点:找孩子容易但是找双亲难

  (3)孩子兄弟表示法[上图](二叉树表示法,二叉链表表示法):用二叉链表作为树的存储结构,链表中的每个结点的两个指针域分别指向第一个孩子结点和下一个兄弟结点

(d)树与二叉树的转化

  (1)将树转化为二叉树:

​       1.加线:在兄弟之间加一连线

​       2.抹线:对每个结点,除了其左孩子以外,去除其与其余孩子之间的关系

​       3.旋转:以树的根结点为轴心,将整个树顺时针旋转45度

  (2)将二叉树转化为树

​       1.加线:若p结点是双亲结点的左孩子,则将p的右孩子,右孩子的右孩子…都于p的双亲连起来

​       2.抹线:抹掉原二叉树中双亲和右孩子之间的连线

​       3.调整:将结点按照层次排列,形成树结构

​    (e)森林与二叉树的转化

​         (1)森林转化成二叉树:

​             1.将各个树转为二叉树

​             2.将每个树的根结点用线相连

​             3.以第一颗树根结点为二叉树的根,再以根结点为轴心,顺时针旋转成二叉树的构型

 

 

​         (2)二叉树转为森林

​             1.抹线:将二叉树中根结点与其右孩子连线,以及沿右分支搜索到的所有右孩子的连线全部抹去,使之变成孤立的二叉树

​             2.还原:将二叉树还原成树

 

(f)树与森林的遍历

​    (1)树的遍历

​         (1)先根(次序)遍历:若树不空,就先访问根结点,再依次先根遍历各个子树

​         (2)后根(次序)遍历:若树不空,就先依次后根遍历各个子树,然后访问根结点

​         (3)按层次遍历:若树不空,则自上而下自左至右访问树中的每个结点

​         (2)森林的遍历

(1)先序遍历:先访问森林中第一颗树的根结点,再先序遍历森林中第一颗树的子树森林,最后先序遍历森林中除了第一颗树以外构成的森林,即从左到右依次对每一棵树进行先序遍历

(2)中序遍历:从左到右依次对森林中的每一颗树进行后根遍历

 

14.哈夫曼树(最优二叉树)

​    (a)判断树:用于描述分类过程的二叉树,不同的判断树在处理相同的数据时的效率是不一样的

​    (b)树的路径长度:从树根到每一个结点的路径长度之和,当结点数目相同时,完全二叉树是路径最短的二叉树,反之不一定成立

​    (c)当树中的每个结点都有一个权后,哈夫曼树也就变成了带权的最优二叉树

​    (d)满二叉树未必是哈夫曼树,哈夫曼树未必唯一

​    (e)构造哈夫曼树的算法叫做哈夫曼算法,其已经在离散数学课中学到,此处不再赘述

(f)包含n个叶子结点的哈夫曼树共有2n-1个结点(因为合并了n-1次),其结点的度数一定是0(原始结点)或2(合并出的新结点),不可能为1

​    (g)哈夫曼树的存储—顺序存储结构[一维结构数组]

​    

15.哈夫曼编码

​    哈夫曼编码能够保证其是前缀码(没有一片树叶是另一片树叶的祖先),且其能保证字符编码的总长最短(带权路径长度最短)

​    哈夫曼编码已经在离散数学中学习过,此处不再赘述了

![image-20210325093646365](C:\Users\fengchuiyusan\AppData\Roaming\Typora\typora-user-images\image-20210325093646365.png)

 ![image-20210325093721030](C:\Users\fengchuiyusan\AppData\Roaming\Typora\typora-user-images\image-20210325093721030.png)![image-20210325093726694](C:\Users\fengchuiyusan\AppData\Roaming\Typora\typora-user-images\image-20210325093726694.png)

![image-20210325093735347](C:\Users\fengchuiyusan\AppData\Roaming\Typora\typora-user-images\image-20210325093735347.png)

![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

                ![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)    

 ![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

![image-20210325093815411](C:\Users\fengchuiyusan\AppData\Roaming\Typora\typora-user-images\image-20210325093815411.png)

![image-20210325093823904](C:\Users\fengchuiyusan\AppData\Roaming\Typora\typora-user-images\image-20210325093823904.png)

![img](file:///C:/Users/FENGCH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

---

## 第四部分	非线性表---图

1.图的基本术语

​    (1)稀疏图:有很少边或者弧的图(e<vlogv)

​    (2)网:边或者弧带权的图

2.图的存储结构

​    (1)邻接矩阵(数组表示法):离散数学中已经学习过,不再赘述

​         其需要两个数组,一个用来存储顶点表,另一个用来存储邻接矩阵